
def is_windows
	RUBY_PLATFORM =~ /win32/i or (RUBY_PLATFORM == "java" and Java::java::lang::System.getProperty("os.name") =~ /Windows/)
end

# due to a bug in JRuby, we cannot use File.join on Windows
# because it keeps using Unix-style seperators
# http://jira.codehaus.org/browse/JRUBY-4522
if is_windows
	class File
		class <<self
			def join2(*args)
				unless is_windows
					return File.join(*args)
				else
					return args.join "\\"
				end
			end

			# expand_path rewrites the path to use
			# forward-slashes -> undo that
			alias expand_path_unix expand_path
			def expand_path(*args)
				expand_path_unix(*args).gsub("/", "\\")
			end
		end
	end
else
	class File
		class <<self
			alias join2 join
		end
	end
end

# FileList cannot handle backslash in file names, so we
# have to give it a forward-slashed path and rewrite the
# result
if is_windows
	class FileList
		class <<self
			alias square_bracket_backup []
			def [](*patterns)
				patterns.flatten!
				square_bracket_backup(patterns.map {|p| p.gsub("\\", "/")}) \
					.map {|p| p.gsub("/", "\\")}
			end
		end
	end
end

# quote character for shell commands
def shell_quote
	if is_windows then
		"\""
	else
		"'"
	end
end

# command seperation character in shell commands
def cmd_sep
	if is_windows then
		"&"
	else
		";"
	end
end


# compile Java sources for helpers project
# We have to do this before we load any Java classes:
# - We load the base classes before we give control back to,
#   so we need to compile now, if not even the base classes
#   are present.
# - If we load part of a class and later recompile it, we may
#   end up with inconsistent classes (and get NoSuchMethodError
#   on a field access).
# Unfortunately, this means that we have to duplicate some of
# the code in Project#run_java_compiler.
ToolProvider = Java::javax::tools::ToolProvider
def run_java_compiler(java_source_dir, java_output_dir)
	classpath = Java::java::lang::System.getProperty("java.class.path")
	args = ["-cp", classpath, "-sourcepath", java_source_dir, "-d", java_output_dir] \
		+ FileList[File.join(java_source_dir, "**", "*.java")]
	compiler = ToolProvider::getSystemJavaCompiler
	if not compiler
		puts "Couldn't get the Java compiler. Please use a JDK to run rake."
		exit 1
	end
	compiler.run(nil, nil, nil, *args)
end
JAVA_HELPERS=File.join2("..", "tests-java-helpers")
compile_helpers = run_java_compiler(
	File.join2(JAVA_HELPERS, "src"),
	File.join2(JAVA_HELPERS, "bin"))


CODE_GENERATOR_DIR = ENV["CODE_GENERATOR_DIR"] || File.join2("..", "upbracing-AVR-CodeGenerator")
CARTOS_DIR = ENV["CARTOS_DIR"] || File.join2("..", "..", "caRTOS", "XMEGAOs", "os")

CC = "avr-gcc"
LD = CC
OBJCOPY = "avr-objcopy"
OBJDUMP = "avr-objdump"
OBJSIZE = "avr-size"

CONFIGURATIONS = ["Debug", "Release"]
BUILD_CONFIGURATIONS = CONFIGURATIONS
TEST_CONFIGURATIONS  = CONFIGURATIONS

F_CPU = 8000000
CFLAGS_COMMON = "-I#{shell_quote}#{File.expand_path CARTOS_DIR}#{shell_quote} -Wall -fpack-struct -fshort-enums -std=gnu99 -funsigned-char -funsigned-bitfields -mmcu=at90can128 -DF_CPU=#{F_CPU}UL"
CFLAGS = {
	"Debug" => CFLAGS_COMMON + " -g2 -gstabs -O0",
	"Release" => CFLAGS_COMMON + " -Os"
}

LDFLAGS_COMMON = "-mmcu=at90can128"
LDFLAGS = {
	"Debug" => LDFLAGS_COMMON,
	"Release" => LDFLAGS_COMMON
}


CODE_GENERATOR_BIN=File.join2(CODE_GENERATOR_DIR, "run")
TARGET_DIR="gen"

# let the user change a few things, e.g. the programmer
# This file must set these constants:
# AVRDUDE = "avrdude -cjtag2 -pc128 -Pusb"
# SERIALPORT = "/dev/ttyUSB0"	# can be a Proc object
begin
	require 'userconfig.rb'
rescue LoadError
	puts "ERROR: Couldn't load userconfig.rb"
	puts "Please create that file. See userconfig.rb.example"
	exit 1
end

# some default values
{ :COLOR => :auto, :UI => :simple }.each do |key,value|
	unless Object.constants.include? key
		Object.const_set key, value
	end
end

# make sure that we have all the constants we expect
user_config_error = false
[:AVRDUDE, :SERIALPORT].each do |name|
	unless Module.constants.include? name or Module.constants.include? name.to_s
		puts "Please set #{name} in userconfig.rb !"
		user_config_error = true
	else
		value = Module.const_get name
		unless value.is_a? String and !value.empty? or value.is_a? Proc
			puts "Invalid value for constant #{name}. Expecting a String or a Proc."
			user_config_error = true
		end
	end
end
exit 1 if user_config_error


# wrap test scripts to print errors to $logger
alias :test_alias :test
def task(*args, &block)
	if block
		task(*args) do |*args2|
			begin
				block.call(*args2)
			rescue
				if $logger
					$logger.error "Error: #{$!}\n" + $!.backtrace.join("\n") rescue nil
				end

				# print message to normale console
				FFI::NCurses::endwin rescue nil

				raise
			end
		end
	else
		task(*args)
	end
end


require 'tempfile'
require 'digest/md5'
require 'java'

begin
	require 'paint'
rescue LoadError, NameError
	# dummy implementation of Paint
	class Paint
		def self.[](string, *options)
			return string
		end

		def mode
			0
		end
	end
end

def md5sum(file)
	# we cannot use File.read(file) because it
	# would rewrite line endings
	content = File.open(file, "rb") do |f|
		f.read
	end
	Digest::MD5.hexdigest(content)
end


# represents a task with more than one output file
# It can either track all outputs or use a dummy file.
class ManyFilesTask < Rake::Task
	attr_accessor :dependent_files, :dummy_file

	def needed?
		targets = if dummy_file then [dummy_file] else @dependent_files end
		targets.each do |file|
			file = file.name.to_s if file.is_a? Rake::FileTask
			if !File.exists?(file) or out_of_date?(File.mtime(file))
				puts "#{self} is outdated because of #{file} (exists: #{File.exists? file})"
				return true
			end
		end

		return false
	end

	# Are there any prerequisites with a later time than the given time stamp?
	def out_of_date?(stamp)
		#@prerequisites.any? { |n| application[n].timestamp > stamp}
		@prerequisites.each { |n|
			if application[n].timestamp > stamp
				puts "#{n} is newer (#{application[n].timestamp} > #{stamp})"
				return true
			end
		}
		return false
	end

	def execute(*args)
		super(*args)
		Rake::touch dummy_file if dummy_file
	end
end

def many_files(name, dependent_files, dummy_file = nil, *args, &block)
	task = ManyFilesTask.define_task(name, *args, &block)
	task.dependent_files = dependent_files
	task.dummy_file = dummy_file
	task
end


$unique_task_id_counter = 0
def unique_task_id(prefix)
	$unique_task_id_counter += 1
	"#{prefix}_#{$unique_task_id_counter}".intern
end


def any_is_newer(old_files, new_files)
	new_files.each do |new_file|
		return true unless File.exists?(new_file)
		old_files.each do |old_file|
			if File.mtime(old_file) > File.mtime(new_file)
				return true
			end
		end
	end

	return false
end


class Dir
	def self.empty?(dir)
		Dir.entries(dir).grep(/^(?!\.\.?$)/).empty?
	end
end


# task generate_all tests all of them
task :generate_all do end

# make generate-all an alias for generate_all (only on the command line!)
task "generate-all" => :generate_all do end


# task build_all builds all hex files (through dependencies)
task :build_all do end

# make build-all an alias for build_all (only on the command line!)
task "build-all" => :build_all do end


# task test_all tests all of them
task :test_all do end

# make test-all an alias for test_all (only on the command line!)
task "test-all" => :test_all do end


# default action is building everything (for now - might change that to running the tests)
task :default => :build_all do end


# clean task removes all build output files and directories
task :clean do end


class Project
	include Rake::DSL

	## build caRTOS library

	def build_caRTOS(features_header_file, configuration = "Debug")
		#TODO make this a special kind of task and implement needed?
		task unique_task_id("caRTOS-lib") => features_header_file do |t|
			# don't do anything, if we don't have a features header file
			# (This can happen, if we expected it to be generated, but it
			#  wasn't because it hasn't been configured in the config file.
			#  This is perfectly ok.)
			if File.exists? features_header_file
				md5 = md5sum(features_header_file)
				target = File.join2(CARTOS_DIR, configuration, "libcaRtos-#{md5}.a")
				cartos_build_dir = File.join2(CARTOS_DIR, configuration)
				# rebuilt, if  library doesn't exist or any input file is newer
				# NOTE We cannot let 'make' decide because 'make' wouldn't rebuilt
				#      any file that has been compiled for a newer, totally different features
				#      file, if we keep the mtime of the features header.
				#      Therefore, we have to force a rebuild by touching the features header.
				os_deps = FileList[ ["*.c", "*.h", "*.inc"].map { |ext| File.join2(CARTOS_DIR, "**", ext) } ]
				unless File.exists?(target) and File.mtime(target) >= File.mtime(features_header_file) \
						and os_deps.all? { |dep| File.mtime(target) >= File.mtime(dep) }
					# rebuild

					# we cannot generate the Makefile - Eclipse has to do that for us
					unless File.exists? File.join2(cartos_build_dir, "makefile")
						raise "No Makefile found. Please use Eclipse to build caRTOS with configuration #{configuration} and try again."
					end

					# copy features header to OS
					features_header_for_build = File.join2(CARTOS_DIR, "config", "Os_cfg_features.h")
					cp features_header_file, features_header_for_build

					# touch features header to force rebuild
					touch features_header_for_build

					# build
					esc = shell_quote
					sh "cd #{esc}#{cartos_build_dir}#{esc} #{cmd_sep} make #{esc}libcaRtos-#{md5}.a#{esc}"

					puts "finished building caRTOS: md5=#{md5}, configuration = #{configuration}"
				end
			else
				puts "INFO: Not linking with caRTOS because the feature file hasn't been generated."
			end
		end
	end


	## run generators

	# config_file => task
	@@generator_task_cache = {}

	def generator_task(name, config_file)
		# use cached value, if it exists
		return @@generator_task_cache[config_file] if @@generator_task_cache[config_file]

		gen_task = create_generator_task(name, config_file)

		@@generator_task_cache[config_file] = gen_task

		return gen_task
	end


	def code_generator_target_dir(config_file)
		dir = File.dirname(config_file)

		File.join2(dir, TARGET_DIR)
	end

	def code_generator_cmdline_for_dependencies(target_dir, config_file)
		esc = shell_quote
		"#{esc}#{CODE_GENERATOR_BIN}#{esc} -C #{esc}#{target_dir}#{esc} #{esc}#{config_file}#{esc}"
	end

	def _stripped_lines(string)
		string.lines.map {|x| x.strip}.select {|x| not x.empty? }.to_a
	end

	#TODO rewrite it to work on Windows (C:\\ and \\ for absolute paths)
	def relative_path(path, parent_dir)
		path2 = File.expand_path path
		parent2 = File.expand_path parent_dir
		if path2.start_with? parent2
			path2 = path2[parent2.length..-1]
			path2 = path2[1..-1] if path2.start_with? "/" or path2.start_with? "\\"
			return path2
		else
			return path
		end
	end

	def do_generate(dir, target_dir, config_file)
		target_dir = relative_path target_dir, dir
		config_file = relative_path config_file, dir

		esc = shell_quote

		sh "cd #{esc}#{dir}#{esc} #{cmd_sep} #{esc}#{File.expand_path CODE_GENERATOR_BIN}#{esc} -C #{esc}#{target_dir}#{esc} #{esc}#{config_file}#{esc}"
	end

	def create_generator_task(name, config_file)
		dir = File.dirname(config_file)

		target_dir = code_generator_target_dir(config_file)

		code_generator = code_generator_cmdline_for_dependencies(target_dir, config_file)

		# dependencies
		dependencies = _stripped_lines(`#{code_generator} -D`)
		dependent_tasks = dependencies.map { |dep| file dep }
		#puts "dependent on code gen: #{dependent_tasks.inspect}"

		# generated files
		generated_files = _stripped_lines(`#{code_generator} -w`)

		# Code generation will generate several files, but maybe only
		# some of them are actually created. Therefore, we track the
		# generation time using an additional file.
		dummy_file = File.join2(target_dir, "last_gen_time")
		gen_task = many_files "generate for #{config_file}", generated_files, dummy_file

		generated_files.each do |gen|
			file gen => gen_task
		end

		# generation task
		gen_task.enhance dependent_tasks do
			#if any_is_newer(dependencies, generated_files)
				do_generate(dir, target_dir, config_file)
			#end
		end

		clean = task "clean for #{config_file}" do
			rm [dummy_file] + generated_files, :force => true
			rmdir target_dir if Dir.exists? target_dir
		end

		task :generate_all => gen_task

		task "clean-#{name}" => clean

		configurations(:build).each do |configuration|
			task "clean-#{name}-#{configuration}" => clean
		end

		task :clean => clean

		return gen_task
	end


	# compile and link

	def find_sources(dir)
		FileList.new(File.join(dir, "**", "*.c"))
	end

	def additional_include_dirs(source_dir, source_file, target_dir, configuration)
		#TODO rewrite for Windows
		["#/../../avr-programs/upbracing-common"]
	end

	def cflags(source_dir, source_file, target_dir, configuration)
		dirs = additional_include_dirs(source_dir, source_file, target_dir, configuration)
		dir_flags = dirs.map { |dir|
			if dir.start_with? "#/"
				rel_path = dir[2..-1]
			elsif dir.start_with? "/"
				rel_path = dir
			elsif is_windows and dir =~ /^([a-zA-Z]:)?[\/\\]/
				rel_path = dir
			else
				rel_path = File.join2(source_dir, dir)
			end
			" #{shell_quote}-I#{rel_path}#{shell_quote}"
		}.join
		#puts dirs.inspect
		#puts dir_flags
		#puts CFLAGS[configuration]
		CFLAGS[configuration] + dir_flags
	end

	def do_compile(cflags, source, target, optional)
		# We ignore source files that may have been generated, but don't exist.
		unless optional and not File.exists?(source)
			# only compile, put output in .o file
			sh "#{shell_quote}#{CC}#{shell_quote} #{cflags} -c -o #{shell_quote}#{target}#{shell_quote} #{shell_quote}#{source}#{shell_quote}"
		else
			puts "INFO: not compiling '#{source}' because it doesn't exist"
		end
	end

	def compile(source_dir, source_file, target_dir, configuration, optional)
		target_file = source_file.sub(/(\.[^.]+)?$/, ".o").sub(/^([A-Za-z]:\\|#)?[.\/\\]/, "")

		target = File.join2(target_dir, target_file)
		if source_file.start_with? "#/"
			source = source_file[2..-1]
		else
			source = File.join2(source_dir, source_file)
		end

		# -MMD means only user header files
		# -MF is the output file
		# -MP create phony targets for the header files - we don't want that
		# -MT is the name of the target - we don't really care
		dependency_file = File.join2(target_dir, target_file + ".d")
		make_dependencies_cflags = "-MMD #{shell_quote}-MF#{dependency_file}#{shell_quote} -MTtarget"

		cflags = cflags(source_dir, source_file, target_dir, configuration) + " " + make_dependencies_cflags

		# determine real target dir
		# This can be a subdirectory of target_dir because source_file
		# (and therefore target_file) can contain directory components.
		real_target_dir = File.dirname(target)
		directory real_target_dir

		t = file target => [source, file(real_target_dir)] do
			do_compile(cflags, source, target, optional)
		end

		# if the dependency file exists, we read its contents
		can_read_dependencies = false
		if File.exists? dependency_file
			# read file contents
			x = File.read(dependency_file)
			# unwrap lines (backslash can escape a newline)
			x = x.gsub("\\\n", "")
			# get first line
			x = x.lines.first

			if x
				# remove target name (before colon)
				x = x.strip.sub(/^[^:]*:\s*/, "")
				# split on spaces
				x = x.split(/\s+/)
				# add dependencies to compile task
				#puts "dependencies for #{target}: #{x.inspect}"
				t.enhance x

				# remember that we are sucessfully using the dependency file
				can_read_dependencies = true
			else
				puts "WARN: Ignoring empty dependencies file '#{dependency_file}'"
			end
		end

		unless can_read_dependencies
			# we don't know the dependencies -> always compile
			force = task unique_task_id("force") { }
			t.enhance [force]
		end

		return t
	end

	def resolve_procs(xs)
		xs = xs.call() if xs.is_a? Proc
		xs.flat_map { |x| if x.is_a? Proc then x.call() || [] else [x] end }
	end

	def link_elf(source_dir, target_dir, name, configuration, objs, libs)
		map_file = File.join2(target_dir, "#{name}.map")
		target = File.join2(target_dir, "#{name}.elf")
		file target => objs.map { |obj| obj[:task] } do
			# libs may be a Proc
			libs = resolve_procs(libs)
			libs_str = libs.map {|x| "-l#{shell_quote}#{x}#{shell_quote}"}.join(" ")

			obj_files = resolve_procs(objs.map { |obj| obj[:for_linker] })
			objs_str = obj_files.map {|x| "#{shell_quote}#{x}#{shell_quote}"}.join(" ")

			sh "#{shell_quote}#{LD}#{shell_quote} #{shell_quote}-Wl,-Map,#{map_file}#{shell_quote} -L#{shell_quote}#{File.join2(CARTOS_DIR, configuration)}#{shell_quote} #{LDFLAGS[configuration]} -o #{shell_quote}#{target}#{shell_quote} #{objs_str} #{libs_str}"
		end
	end

	def name_from_source_dir(source_dir)
		name = source_dir
		# 1. remove number prefix (0015-...)
		# 2. remove number prefix of subdirs
		# 3. replace directory seperators by '-'
		name.sub(/^[0-9]+[-_ ]?/, "").gsub(/[\/\\][0-9]+[-_ ]?/, "/").gsub(/[\/\\]/, "-")
	end

	def get_target_dir(source_dir, configuration)
		File.join2(source_dir, "bin", configuration)
	end

	def get_generator_config(source_dir, configuration)
		File.join2(source_dir, "config.rb")
	end

	def get_features_header_file(source_dir, configuration)
		File.join2(source_dir, "Os_cfg_features.h")
	end

	def get_generated_sources(source_dir, generator_config, gen_task)
		gen_task.dependent_files.select { |x| x =~ /\.c$/ }
	end

	def get_generated_features_header_file(source_dir, generator_config, gen_task, generated_sources)
		#TODO: allow in other places, e.g. root of test folder
		File.join2(source_dir, "gen", "Os_cfg_features.h")
	end

	def get_libs(features_header_file, source_dir, name, configuration, sources)
		if features_header_file
			# The features header file might be regenerated, so we cannot know the MD5
			# right now. Instead, we supply a lambda that will be evaluated right before
			# the linker is called. We cache the result, so we won't have to calculate it
			# more than once.
			libs = nil
			return lambda do
				unless libs
					if features_header_file and File.exists? features_header_file
						features_md5 = md5sum(features_header_file)
						libs = ["caRtos-#{features_md5}"]
					else
						libs = []
					end
				end
				libs
			end
		else
			return []
		end
	end

	def create_lss_task(source_dir, target_dir, name, elf, configuration)
		# create extended listing
		# (not enforced by dependencies)
		lss_file = File.join2(target_dir, "#{name}.lss")
		file lss_file => elf do
			sh "#{shell_quote}#{OBJDUMP}#{shell_quote} -h -S #{shell_quote}#{elf.name}#{shell_quote}  >#{shell_quote}#{lss_file}#{shell_quote}"
		end
	end

	def create_hex_task(source_dir, target_dir, name, elf, configuration)
		# create HEX task
		flash_hex_file = File.join2(target_dir, "#{name}.hex")
		file flash_hex_file => elf do
			sh "#{shell_quote}#{OBJCOPY}#{shell_quote} -R .eeprom -O ihex #{shell_quote}#{elf.name}#{shell_quote} #{shell_quote}#{flash_hex_file}#{shell_quote}"
		end
	end

	def create_eeprom_task(source_dir, target_dir, name, elf, configuration)
		# create EEPROM HEX task
		# (not enforced by dependencies)
		eeprom_hex_file = File.join2(target_dir, "#{name}.eep")
		file eeprom_hex_file => elf do
			flags = "-j .eeprom --no-change-warnings --change-section-lma .eeprom=0 -O ihex"
			sh "#{shell_quote}#{OBJCOPY}#{shell_quote} #{flags} #{shell_quote}#{elf.name}#{shell_quote} #{shell_quote}#{eeprom_hex_file}#{shell_quote}"
		end
	end

	def create_size_task(source_dir, target_dir, name, elf, configuration)
		# print size
		task "#{name}-size-#{configuration}" => elf do
			sh "#{shell_quote}#{OBJSIZE}#{shell_quote} --format=avr --mcu=at90can128 #{shell_quote}#{elf.name}#{shell_quote}"
		end
	end

	def additional_source_files(source_dir, name, configuration)
		[]
	end

	def build(source_dir, configuration)
		# output name is the name of the directory
		name = name_from_source_dir(source_dir)

		# determine target directory
		target_dir = get_target_dir(source_dir, configuration)

		# create generator task, if we have a config.rb file
		generator_config = get_generator_config(source_dir, configuration)
		features_header_file = nil
		generated_sources = []
		if generator_config and File.exists? generator_config
			# create generator task
			#TODO put generated files in bin folder?
			gen_task = generator_task(name, generator_config)

			# remember generated source files because we have to compile them
			generated_sources = get_generated_sources(source_dir, generator_config, gen_task)

			# create caRTOS library builder task
			# (uses generated features header)
			features_header_file = get_generated_features_header_file(source_dir, generator_config, gen_task, generated_sources)
		end

		# If we don't generate any files, we might still have a features header file.
		if !features_header_file
			maybe_features_header_file = get_features_header_file(source_dir, configuration)
			features_header_file = maybe_features_header_file if maybe_features_header_file and File.exists? maybe_features_header_file
		end


		# find all source files (*.c)
		sources = find_sources(source_dir)
		sources += generated_sources
		sources += additional_source_files(source_dir, name, configuration)

		# remember that the generated source files can be ignored, if they don't exist
		optional_sources = generated_sources

		# strip prefix from sources
		sources = sources.map { |source| relative_path source, source_dir }
		optional_sources = optional_sources.map { |source| relative_path source, source_dir }

		# remove duplicates (generated sources will be found, if they already exist)
		sources.uniq!
		optional_sources.uniq!


		# create compile tasks
		objs = sources.map { |source|
			optional = optional_sources.include?(source)
			obj_task = compile(source_dir, source, target_dir, configuration, optional)
			if not optional
				obj_file_for_linker = obj_task
			else
				# the file is optional -> only pass to linker, if source exists
				obj_file_for_linker = lambda { File.exists?(source) && obj_task }
			end
			{ :task => obj_task, :for_linker => obj_file_for_linker }
		}

		# make sure that we generate before we compile
		if gen_task
			objs.each do |obj|
				obj[:task].enhance [gen_task]
			end
		end

		return nil unless objs and not objs.empty?

		# get libraries (probably a future value (Proc))
		libs = get_libs(features_header_file, source_dir, name, configuration, sources)

		# create linker task
		elf = link_elf(source_dir, target_dir, name, configuration, objs, libs)

		# make sure we build the caRTOS library before linking the application
		# (only if we have a features header file)
		if features_header_file
			cartos_lib_task = build_caRTOS(features_header_file, configuration)

			# add dependency to linker task
			elf.enhance [cartos_lib_task] if cartos_lib_task
		end

		create_lss_task(source_dir, target_dir, name, elf, configuration)

		flash_hex_file = create_hex_task(source_dir, target_dir, name, elf, configuration)
		
		create_eeprom_task(source_dir, target_dir, name, elf, configuration)

		create_size_task(source_dir, target_dir, name, elf, configuration)

		build_task = task("build-#{name}-#{configuration}" => flash_hex_file) {}

		# make sure that the hex file is generated, if someone calls build-all
		task :build_all => build_task

		# another task to build all configurations of this project
		task "build-#{name}" => build_task

		# clean task
		clean = task "clean-#{name}-#{configuration}" do
			rm_rf target_dir
		end
		task "clean-#{name}" => clean

		# return hex file task
		flash_hex_file
	end
end

# Provide information about JRuby's notion of the current
# directory to RichToolkit. We have to do that because
# JRuby keeps its own copy of the current directory
# because in Java it cannot be changed.
# makeAbsolute methods has to be created in test script context to
# capture the right copy of the current directory (even in JRuby
# we have more than one *g*). Therefore, we save it as a string
# and execute it later.
RubyPWdProviderCode = <<EOF
class RubyPWdProvider
	include Java::de::upbracing::code_generation::tests::RichToolkit::PwdProvider

	def makeAbsolute(path)
		#puts "makeAbsolute(\#{path.inspect}) -> \#{File.expand_path(path || ".").inspect}"
		File.expand_path(path || ".")
	end
end
$toolkit.pwd_provider = RubyPWdProvider.new
EOF


begin
	#puts "Setting serial port: #{SERIALPORT.inspect} - #{[*SERIALPORT].inspect}"
	#Java::de::upbracing::code_generation::tests::serial::SerialHelper::DEFAULT_PORTS = [*SERIALPORT]
	SerialHelper = Java::de::upbracing::code_generation::tests::serial::SerialHelper
rescue NameError
	# SerialHelper not available
	SerialHelper = nil
end

if SerialHelper
	class DefaultSerialPortProvider
		include SerialHelper::SerialPortProvider

		def initialize(ports)
			@ports = ports
		end

		def getSerialPorts
			[*@ports].map do |x|
				if x.is_a? Proc
					x.call
				else
					x
				end
			end
		end
	end
end


begin
	PIOType = Java::de::upbracing::code_generation::tests::context::ProgramIO::Type
rescue LoadError, NameError
	puts "Please build the tests-java-helpers project with Eclipse. You need to import"
	puts "the project and all dependency projects into your Eclipse workspace."
	exit 1
end
StringBuffer = Java::java::lang::StringBuffer
Messages = Java::de::upbracing::code_generation::Messages
Severity = Messages::Severity
TestFailed = Java::de::upbracing::code_generation::tests::TestFailedException
TestResult = Java::de::upbracing::code_generation::tests::context::Result

begin
	OutputFormatter = Java::de::upbracing::code_generation::tests::simple::SimpleToolkit::OutputFormatter
rescue NameError
	# simple UI not available
	OutputFormatter = nil
end
if OutputFormatter
	class PaintOutputFormatter
		include OutputFormatter

		def alter_lines(text)
			text.lines.map { |line| yield line }.join
		end

		def alter_lines2(text)
			alter_lines(text) do |line|
				if line.end_with? "\n"
					line = line.sub(/\n$/, "")
					(yield line, true) + "\n"
				else
					yield line, false
				end
			end
		end

		def left_bar(bar, text)
			alter_lines(text) { |line| bar + line }
		end

		def printPrompt(prompt)
			if prompt and not prompt.empty?
				prompt = left_bar(Paint[" ", nil, :blue] + " ", prompt)
				print prompt
			end
		end

		def printInstructions(instructions)
			instructions = instructions.sub(/\n*$/, '')
			puts left_bar(Paint["I", :black, :white] + " ", instructions)
		end

		def printProgramIO(data, type)
			foreground = case type
			when PIOType::IN
				[:green]
			when PIOType::OUT
				[:white, :bright]
			when PIOType::ERROR
				[:red, :bright, :bold]
			else
				raise "unknown type of program IO: #{type}"
			end

			#data = data.gsub(/[^ -z]/) { |x| sprintf("\\x%02x", x.ord) }

			print alter_lines2(data) { |line| Paint[line, *foreground, [50,50,50]] }
		end

		def reportProgramResult(program, result)
			name = program.name
			#name = Paint[program.name, nil, [50,50,50]]

			if result.isSuccessful
				puts "#{name} finished successfully"
			else
				puts name + ": " + Paint[result.message, :red]
			end
		end

		def showMessage(msg)
			sb = StringBuffer.new
			msg.format(sb, "  ")
			color = case msg.severity
			when Severity::FATAL, Severity::ERROR
				[:red, :bright, :bold]
			when Severity::WARNING
				Paint.mode == 256 and ["#ff4a12", :bold] or [:yellow, :bold]
			else
				[:bold]	#nil
			end
			if color and Paint.mode > 0
				print sb.toString.sub(/^(.*?):/, Paint["\\1", *color] + ":")
			else
				print sb.toString
			end
		end

		def printSerialIO(data, is_input, port_no)
			foreground = if is_input then [:green] else [:white, :bright] end

			#data = data.gsub(/[^ -z]/) { |x| sprintf("\\x%02x", x.ord) }

			print alter_lines2(data) { |line| Paint[line, *foreground, [0,0,100]] }
		end
	end
end

class NCursesUI
	include Java::de::upbracing::code_generation::tests::TestUI

	def name
		return "ncurses"
	end

	def available
		# We really cannot know whether NCurses is available. Probably we
		# could use newwin, but I cannot find any useful documentation and
		# its implementation in ffi-ncurses seems to be wrong (4 parameters).
		# Best guess: If we have colors, we can probably use ncurses.
		#Paint.mode > 0 and not is_windows
		return false unless Paint.mode > 0

		# We need to make sure that we have the library.
		begin
			require 'ffi-ncurses'
		rescue LoadError => e
			puts "WARN: Couldn't load ncurses native library."
			puts "  " + e.to_s
		end
	end

	def createToolkit
		require 'ncurses-ui.rb'
		NCursesToolkit.new
	end
end

begin
	Java::de::upbracing::code_generation::tests::ncurses::NCursesUI::setRubyUI NCursesUI.new
rescue
	puts "WARN: Couldn't pass wrapper class for ncurses UI to Java. ncurses UI won't be available."
end

# hook into Rake to notify $toolkit on shutdown
class Rake::Application
	# Rake::Application is already running, so we have to make
	# sure that we hook a method that is not running, but will
	# be called
	# top_level will be called after load_rakefile, so we use that
	# around that (in method run) is a call to
	# standard_exception_handling which uses exit(false). This seems
	# to thwart the addShutdownHook that NCursesToolkit uses
	alias :top_level_original :top_level
	def top_level(*args, &block)
		begin
			puts "In hooked top_level"
			top_level_original(*args, &block)
		ensure
			$toolkit.tearDown if $toolkit
		end
	end

	# print errors to log
	alias :display_error_message_original :display_error_message
	def display_error_message(ex)
		# save to log, if we have one
		log = $log || $logger
		if log
			begin
				msg = "#{ex.class.name}: #{ex.message}\n" + ex.backtrace.join("\n")
				msg += "\n  Tasks: #{ex.chain}" if ex.respond_to?(:chain) && ex.chain
				log.error(msg)
			rescue
				# ignore
				puts "error logging message"
			end
		end

		# print message to normale console
		FFI::NCurses::endwin rescue nil

		# let Rake do its stuff -> print to console
		display_error_message_original(ex)
	end
end

class TestHelper
	attr_accessor :toolkit
	attr_accessor :avrdude, :serialport
	attr_accessor :name, :build_dir, :source_dir, :configuration

	# set up environment for tests; called automatically
	def start
		$toolkit = @toolkit
		@toolkit.inner.output_formatter = PaintOutputFormatter.new if OutputFormatter \
					and @toolkit.inner.is_a? Java::de::upbracing::code_generation::tests::simple::SimpleToolkit
		@toolkit.serial_port_provider = DefaultSerialPortProvider.new SERIALPORT if SerialHelper
		@toolkit.start
	end

	# delegate method calls to RichToolkit ($toolkit) or
	# the real Toolkit ($toolkit.inner), if this object
	# cannot handle them
	def method_missing(m, *args, &block)
		if toolkit.respond_to? m
			toolkit.send(m, *args, &block)
		elsif toolkit.inner.respond_to? m
			toolkit.inner.send(m, *args, &block)
		else
			# error
			super(m, *args, &block)
		end
	end

	def erase_processor
		system "#{@avrdude} -e"
	end

	def flash_processor_action(parts = [:flash])
		parts = [parts] if parts.is_a? String or parts.is_a? Symbol
		return { "dependencies" => [], "cmdline" => "" } if parts.empty?

		dependencies = []
		commands = ""
		parts.each do |part|
			part = part.intern if part.is_a? String
			type = part.to_s
			case part
			when :flash, :application
				ext = "hex"
			when :eeprom
				ext = "eep"
			when :efuse, :lfuse, :hfuse, /^fuse[0-9]+$/, :calibration
				ext = part.to_s
			else
				raise "Unsupported type of memory: #{part}"
			end

			file = File.join2(@build_dir, "#{@name}.#{ext}")
			dependencies << file
			commands += " #{shell_quote}-U#{type}:w:#{File.expand_path(file)}:a#{shell_quote}"
		end

		cmdline = @avrdude + commands

		{ "dependencies" => dependencies, "cmdline" => cmdline }
	end

	def flash_processor(parts = [:flash])
		#TODO use Toolkit
		system flash_processor_action(parts)["cmdline"]
	end
end

class Project

	## build Java helpers that are specific to this project

	def get_java_sources(java_source_dir)
		FileList[File.join(java_source_dir, "**", "*.java")]
	end

	def compiler_classpath(java_source_dir)
		Java::java::lang::System.getProperty("java.class.path")
	end

	def run_java_compiler(java_source_dir, java_output_dir)
		classpath = compiler_classpath(java_source_dir)
		args = ["-cp", classpath, "-sourcepath", java_source_dir, "-d", java_output_dir] \
			+ get_java_sources(java_source_dir)
		compiler = ToolProvider::getSystemJavaCompiler
		if not compiler
			puts "Couldn't get the Java compiler. Please use a JDK to run rake."
			exit 1
		end
		compiler.run(nil, nil, nil, *args)
	end

	def get_java_source_dir(project_dir)
		File.join2(project_dir, "java")
	end

	def get_java_output_dir(project_dir)
		File.join2(project_dir, "bin", "java")
	end

	def create_java_task(project_dir)
		java_source_dir = get_java_source_dir(project_dir)
		if File.exists? java_source_dir
			java_output_dir = get_java_output_dir(project_dir)

			create_java_task2(project_dir, java_source_dir, java_output_dir)
		else
			nil
		end
	end

	def create_java_task2(project_dir, java_source_dir, java_output_dir)
		directory java_output_dir

		java_sources = get_java_sources(java_source_dir)
		class_files = java_sources.map { |x| x.sub(java_source_dir, java_output_dir).sub(/\.[^.]+$/, ".class") }

		compile_java_task = many_files "compile java files in #{java_source_dir}", class_files

		compile_java_task.enhance([file(java_output_dir)] + java_sources) do
			run_java_compiler(java_source_dir, java_output_dir)
		end

		compile_java_task
	end

	## run tests

	Ruby = Java::org::jruby::Ruby

	def run_jruby_script(script_filename, classpath = nil, global_variables = {})
		engine = Ruby.newInstance

		init_code = global_variables[:init]
		global_variables.delete :init

		global_variables.each do |key, value|
			#TODO support methods
			if key =~ /^[A-Z]/
				engine.defineGlobalConstant(key, value)
			elsif value.is_a? Method
				# we have to get the DynamicMethod object which
				# is stored in the private field method
				cls = Java::java::lang::Class.for_name("org.jruby.RubyMethod")
				field = cls.getDeclaredField("method")
				field.setAccessible true
				method = field.get(value)

				# We have to add it to some class or module. Here we are
				# using Kernel.
				#TODO I would like to add it to the main object, but I don't
				#     know how to get that object.
				target = engine.kernel

				# now we can set this on the Ruby instance
				# Unfortunately, we cannot access the addMethod method
				# directly, so we use reflection.
				mod_cls = Java::java::lang::Class.for_name("org.jruby.RubyModule")
				add_method = mod_cls.declared_methods.select {|x| x.name == "addMethod"}.first
				add_method.invoke(target, key.to_s, method)
			else
				engine.defineReadonlyVariable(key, value)
			end
		end

		# add some entries to the classpath
		if classpath
			engine.defineReadonlyVariable("$additional_classpath", classpath)
			engine.executeScript("$additional_classpath.each { |x| $CLASSPATH << x }", "extend classpath")
		end

		# load some helpers
		engine.executeScript(File.read("test-helpers.rb"), "test-helpers.rb")

		# change to directory of the script file
		engine.current_directory = File.expand_path(File.dirname(script_filename))

		# run init code
		engine.executeScript(init_code, "init code") if init_code

		# execute test script
		engine.executeScript(File.read(script_filename), script_filename)
	end

	def get_test_script(dir, configuration)
		File.join2(dir, "run-test.rb")
	end

	def get_test_dependencies(project_dir, test_helper)
		test_helper.flash_processor_action()["dependencies"].map { |x| File.join2(project_dir, x) }
	end

	def create_test_helper(name, build_dir)
		TestHelper.new
	end

	def test_classpath(project_dir, test_helper)
		java_source_dir = get_java_source_dir(project_dir)
		if File.exists? java_source_dir
			[get_java_output_dir(project_dir)]
		else
			[]
		end
	end

	def get_toolkit
		unless $toolkit
			ui = UI
			if ui.is_a? Array
				ui = ui.map {|x| x.to_s}
			else
				ui = [ui.to_s]
			end
			$toolkit = Java::de::upbracing::code_generation::tests::TestUILoader.createToolkit(ui)
		end
		return $toolkit
	end

	def add_to_test_all(dir, configuration, test)
		#TODO How can we enforce the order? Does rake honour the order that
		#     we use for adding the dependencies?
		task :test_all => test
	end

	def run_test(dir, configuration)
		source_dir = dir
		name = name_from_source_dir source_dir

		build_dir = get_target_dir(dir, configuration)

		test_helper = create_test_helper(name, build_dir)
		test_helper.name          = name
		test_helper.build_dir     = relative_path build_dir,  dir
		test_helper.source_dir    = relative_path source_dir, dir
		test_helper.avrdude       = AVRDUDE
		test_helper.serialport    = SERIALPORT
		test_helper.configuration = configuration

		toolkit = get_toolkit
		test_helper.toolkit = toolkit

		test_script = get_test_script(dir, configuration)

		test = task "test-#{name}-#{configuration}" => get_test_dependencies(dir, test_helper) do |selftask|
			puts "Running test '#{dir}' (#{configuration})..."

			raise "Test script not found at '#{test_script}'" unless File.exists? test_script

			classpath = test_classpath(dir, test_helper)

			begin
				run_jruby_script test_script, classpath,					\
					:AVRDUDE => AVRDUDE, :SERIALPORT => SERIALPORT, 		\
					"$helper" => test_helper,								\
					:init => "$helper.start" + "\n" + RubyPWdProviderCode,	\
					:TestResult => TestResult, :SerialHelper => SerialHelper
			rescue TestFailed => ex
				message = "Test failed: " + ex.message

				throwable = ex.cause || ex.result && ex.result.status == "error" && ex.result.exception
				if throwable
					# get full backtrace
					bt = throwable.backtrace.join("\r\n\t\t")
					
					# cut trace after run_test method
					bt = bt.sub(/(Rakefile:[0-9]+:in `run_test').*$/m, "\\1\r\n\t\tin task #{selftask}")

					message += "\r\n\t\t" + bt

					message += "\r\n\tin test:"
				end

				# get full backtrace
				bt = ex.backtrace.join("\r\n\t\t")
				
				# cut trace after run_test method
				bt = bt.sub(/(Rakefile:[0-9]+:in `run_test').*$/m, "\\1\r\n\t\tin task #{selftask}")

				message += "\r\n\t\t" + bt


				log = toolkit.inner.messages || $log || $logger
				if log
					log.error message.gsub("\r\n", "\n")
				else
					puts message
				end
			rescue Exception => ex
				#TODO use toolkit.messages

				# get full backtrace
				bt = ex.backtrace.join("\r\n\t")
				
				# cut trace after run_test method
				bt = bt.sub(/(Rakefile:[0-9]+:in `run_test').*$/m, "\\1\r\n\tin task #{selftask}")

				message = "Exception in test script #{test_script}:\r\n" +
					"\t" + ex.class.to_s + "\r\n" +
					"\t" + ex.message.to_s + "\r\n" +
					"\t" + bt

				log = toolkit.inner.messages || $log || $logger
				if log
					log.error message.gsub("\r\n", "\n")
				else
					puts message
				end
			end
		end

		# alias for this task because I always get it wrong ;-)
		task "run-#{name}-#{configuration}" => test

		task "test-#{name}" => test
		task "run-#{name}" => test

		add_to_test_all(dir, configuration, test)

		return test
	end


	# main method

	def create_tasks(dir, dependencies_for_run)
		compile_java_task = create_java_task(dir)

		configurations(:build).each do |configuration|
			# build hex file
			build_task = build dir, configuration

			build_task.enhance [compile_java_task] if compile_java_task
		end

		# clean task
		name = name_from_source_dir dir
		clean = task "clean-#{name}" do
			target_dir = get_target_dir(dir, "")
			rmdir target_dir if Dir.exists?(target_dir) and Dir.empty?(target_dir)
		end
		task :clean => clean

		configurations(:test).each do |configuration|
			# run test
			run_task = run_test dir, configuration

			run_task.enhance dependencies_for_run
		end
	end

	def configurations(which)
		case which
		when :build
			BUILD_CONFIGURATIONS
		when :test
			TEST_CONFIGURATIONS
		else
			CONFIGURATIONS
		end
	end
end

class ProjectWithCommon < Project
	@@common_libraries = {
		"rs232" => { :sources => ["rs232.c", "rs232-helpers.c"] }
	}

	def initialize
		@used_common_source_files = []
	end

	def additional_include_dirs(source_dir, source_file, target_dir, configuration)
		["#/common"] + super
	end

	def additional_source_files(source_dir, name, configuration)
		@used_common_source_files + super
	end

	def add_common(*args)
		args.each do |arg|
			arg = arg.to_s
			lib = @@common_libraries[arg]
			if lib
				sources = lib[:sources].map { |file| "#/common/#{file}" }
				@used_common_source_files.push(*sources)
			elsif File.exists? "common/#{arg}.c"
				@used_common_source_files << "common/#{arg}.c"
			elsif File.exists? "common/#{arg}"
				@used_common_source_files << "common/#{arg}"
			else
				raise "not found: common file or library '#{arg}'"
			end
		end
	end
end

# We use ScriptEngine here. It should create a new instance of JRuby (and in some way
# it does), but it shares global variables and a few other things. This is quite convenient
# for loading the project config because it will need some rake stuff.
ScriptEngineManager = Java::javax::script::ScriptEngineManager
ScriptEngine = Java::javax::script::ScriptEngine
InputStreamReader = Java::java::io::InputStreamReader
Charset = Java::java::nio::charset::Charset
FileInputStream = Java::java::io::FileInputStream
def load_project_config(dir)
	project_config = File.join2(dir, "project.rb")
	if File.exists? project_config
		jruby = ScriptEngineManager.new.getEngineByName("jruby")
		raise "Couldn't find the JRuby engine!" unless jruby

		#TODO give it a chance to alter the test object, as well
		jruby.put "Project", Project

		old_pwd = Dir.pwd
		jruby.put("directory", dir)
		jruby.eval("Dir.chdir($directory)")

		jruby.put(ScriptEngine.FILENAME, project_config)

		# save list of constants
		all_consts = Object.constants.clone

		script_reader = InputStreamReader.new(FileInputStream.new(project_config), Charset.forName("utf-8"))
		jruby.eval script_reader
		script_reader.close()

		# restore working directory
		Dir.chdir old_pwd

		project = jruby.get("project")

		# remove constants that have been created by the script
		#puts "new constants after loading #{project_config}: " + (Object.constants - all_consts).inspect
		keep_constants = jruby.get("keep_constants") || []
		(Object.constants - all_consts - keep_constants).each do |const_name|
			Object.send(:remove_const, const_name)
		end
	else
		project = Project.new
	end

	return project
end

# add tasks for all directories which have certain files
magic_files = FileList["**/run-test.rb", "**/config.rb", "**/project.rb", "**/main.c", "**/main-*.c"]
project_dirs = magic_files.map { |file| File.dirname(file) }
project_dirs.uniq!
project_dirs.sort!
project_dirs.each do |dir|
	puts "project: #{dir}"
	# special case: 'common' directory is not a test
	if dir != "common/"
		project = load_project_config(dir)

		project.create_tasks(dir, [compile_helpers]) if project

		#puts "-I: #{project.additional_include_dirs(nil,nil,nil,nil).inspect}"
	end
end

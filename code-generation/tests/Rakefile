CODE_GENERATOR_DIR = ENV["CODE_GENERATOR_DIR"] || "../upbracing-AVR-CodeGenerator"
CARTOS_DIR = ENV["CARTOS_DIR"] || "../../caRTOS/XMEGAOs/os"

CC = "avr-gcc"
LD = CC
OBJCOPY = "avr-objcopy"
OBJDUMP = "avr-objdump"
OBJSIZE = "avr-size"

CONFIGURATIONS = ["Debug", "Release"]
BUILD_CONFIGURATIONS = CONFIGURATIONS
TEST_CONFIGURATIONS  = CONFIGURATIONS

F_CPU = 8000000
CFLAGS_COMMON = "-I'#{File.expand_path CARTOS_DIR}' -Wall -fpack-struct -fshort-enums -std=gnu99 -funsigned-char -funsigned-bitfields -mmcu=at90can128 -DF_CPU=#{F_CPU}UL"
CFLAGS = {
	"Debug" => CFLAGS_COMMON + " -g2 -gstabs -O0",
	"Release" => CFLAGS_COMMON + " -Os"
}

LDFLAGS_COMMON = "-mmcu=at90can128"
LDFLAGS = {
	"Debug" => LDFLAGS_COMMON,
	"Release" => LDFLAGS_COMMON
}


CODE_GENERATOR_BIN="#{CODE_GENERATOR_DIR}/run"
TARGET_DIR="gen"

# let the user change a few things, e.g. the programmer
# This file must set these constants:
# AVRDUDE = "avrdude -cjtag2 -pc128 -Pusb"
# SERIALPORT = "/dev/ttyUSB0"	# can be a Proc object
begin
	require 'userconfig.rb'
rescue LoadError
	puts "ERROR: Couldn't load userconfig.rb"
	puts "Please create that file. See userconfig.rb.example"
	exit 1
end

# some default values
{ :COLOR => :auto, :UI => :simple }.each do |key,value|
	unless Object.constants.include? key
		Object.const_set key, value
	end
end

# make sure that we have all the constants we expect
user_config_error = false
[:AVRDUDE, :SERIALPORT].each do |name|
	unless Module.constants.include? name or Module.constants.include? name.to_s
		puts "Please set #{name} in userconfig.rb !"
		user_config_error = true
	else
		value = Module.const_get name
		unless value.is_a? String and !value.empty? or value.is_a? Proc
			puts "Invalid value for constant #{name}. Expecting a String or a Proc."
			user_config_error = true
		end
	end
end
exit 1 if user_config_error


require 'tempfile'
require 'digest/md5'
require 'java'

begin
	require 'paint'
rescue
	# dummy implementation of Paint
	class Paint
		def self.[](string, *options)
			return string
		end

		def mode
			0
		end
	end
end

def md5sum(file)
	Digest::MD5.hexdigest(File.read(file))
end


class ManyFilesTask < Rake::Task
	attr_accessor :dependent_files

	def needed?
		@dependent_files.each do |file|
			file = file.name.to_s if file.is_a? Rake::FileTask
			if !File.exists?(file) or out_of_date?(File.mtime(file))
				puts "#{self} is outdated because of #{file} (exists: #{File.exists? file})"
				return true
			end
		end

		return false
	end

	# Are there any prerequisites with a later time than the given time stamp?
	def out_of_date?(stamp)
		#@prerequisites.any? { |n| application[n].timestamp > stamp}
		@prerequisites.each { |n|
			if application[n].timestamp > stamp
				puts "#{n} is newer (#{application[n].timestamp} > #{stamp})"
				return true
			end
		}
		return false
	end
end

def many_files(name, dependent_files, *args, &block)
	task = ManyFilesTask.define_task(name, *args, &block)
	task.dependent_files = dependent_files
	task
end


$unique_task_id_counter = 0
def unique_task_id(prefix)
	$unique_task_id_counter += 1
	"#{prefix}_#{$unique_task_id_counter}".intern
end


def any_is_newer(old_files, new_files)
	new_files.each do |new_file|
		return true unless File.exists?(new_file)
		old_files.each do |old_file|
			if File.mtime(old_file) > File.mtime(new_file)
				return true
			end
		end
	end

	return false
end


class Dir
	def self.empty?(dir)
		Dir.entries(dir).grep(/^(?!\.\.?$)/).empty?
	end
end


# task generate_all tests all of them
task :generate_all do end

# make generate-all an alias for generate_all (only on the command line!)
task "generate-all" => :generate_all do end


# task build_all builds all hex files (through dependencies)
task :build_all do end

# make build-all an alias for build_all (only on the command line!)
task "build-all" => :build_all do end


# task test_all tests all of them
task :test_all do end

# make test-all an alias for test_all (only on the command line!)
task "test-all" => :test_all do end


# default action is building everything (for now - might change that to running the tests)
task :default => :build_all do end


# clean task removes all build output files and directories
task :clean do end


class Project
	include Rake::DSL

	## build caRTOS library

	def build_caRTOS(features_header_file, configuration = "Debug")
		#TODO make this a special kind of task and implement needed?
		task unique_task_id("caRTOS-lib") => features_header_file do |t|
			md5 = md5sum(features_header_file)
			target = File.join(CARTOS_DIR, configuration, "libcaRtos-#{md5}.a")
			cartos_build_dir = File.join(CARTOS_DIR, configuration)
			# rebuilt, if  library doesn't exist or any input file is newer
			# NOTE We cannot let 'make' decide because 'make' wouldn't rebuilt
			#      any file that has been compiled for a newer, totally different features
			#      file, if we keep the mtime of the features header.
			#      Therefore, we have to force a rebuild by touching the features header.
			os_deps = FileList[ ["*.c", "*.h", "*.inc"].map { |ext| File.join(CARTOS_DIR, "**", ext) } ]
			unless File.exists?(target) and File.mtime(target) >= File.mtime(features_header_file) \
					and os_deps.all? { |dep| File.mtime(target) >= File.mtime(dep) }
				# rebuild

				# we cannot generate the Makefile - Eclipse has to do that for us
				unless File.exists? File.join(cartos_build_dir, "makefile")
					raise "No Makefile found. Please use Eclipse to build caRTOS with configuration #{configuration} and try again."
				end

				# copy features header to OS
				features_header_for_build = File.join(CARTOS_DIR, "config", "Os_cfg_features.h")
				cp features_header_file, features_header_for_build

				# touch features header to force rebuild
				touch features_header_for_build

				# build
				sh "cd '#{cartos_build_dir}' ; make 'libcaRtos-#{md5}.a'"

				puts "finished building caRTOS: md5=#{md5}, configuration = #{configuration}"
			end
		end
	end


	## run generators

	# config_file => task
	@@generator_task_cache = {}

	def generator_task(config_file)
		# use cached value, if it exists
		return @@generator_task_cache[config_file] if @@generator_task_cache[config_file]

		gen_task = create_generator_task(config_file)

		@@generator_task_cache[config_file] = gen_task

		task :generate_all => gen_task

		return gen_task
	end


	def code_generator_target_dir(config_file)
		dir = File.dirname(config_file)

		File.join(dir, TARGET_DIR)
	end

	def code_generator_cmdline_for_dependencies(target_dir, config_file)
		"'#{CODE_GENERATOR_BIN}' -C '#{target_dir}' '#{config_file}'"
	end

	def _stripped_lines(string)
		string.lines.map {|x| x.strip}.to_a
	end

	def relative_path(path, parent_dir)
		path2 = File.expand_path path
		parent2 = File.expand_path parent_dir
		if path2.start_with? parent2
			path2 = path2[parent2.length..-1]
			path2 = path2[1..-1] if path2.start_with? "/" or path2.start_with? "\\"
			return path2
		else
			return path
		end
	end

	def do_generate(dir, target_dir, config_file)
		target_dir = relative_path target_dir, dir
		config_file = relative_path config_file, dir

		sh "cd '#{dir}' ; '#{File.expand_path CODE_GENERATOR_BIN}' -C '#{target_dir}' '#{config_file}'"
	end

	def create_generator_task(config_file)
		dir = File.dirname(config_file)

		target_dir = code_generator_target_dir(config_file)

		code_generator = code_generator_cmdline_for_dependencies(target_dir, config_file)

		# dependencies
		dependencies = _stripped_lines(`#{code_generator} -D`)
		dependent_tasks = dependencies.map { |dep| file dep }

		# generated files
		generated_files = _stripped_lines(`#{code_generator} -w`)

		gen_task = many_files "generate for #{config_file}", generated_files

		generated_files.each do |gen|
			file gen => gen_task
		end

		# generation task
		gen_task.enhance dependent_tasks do
			#if any_is_newer(dependencies, generated_files)
				do_generate(dir, target_dir, config_file)
			#end
		end

		clean = task "clean for #{config_file}" do
			rm generated_files, :force => true
			rmdir target_dir if Dir.exists? target_dir
		end
		task :clean => clean

		return gen_task
	end


	# compile and link

	def find_sources(dir)
		FileList.new(File.join(dir, "**", "*.c"))
	end

	def additional_include_dirs(source_dir, source_file, target_dir, configuration)
		["#/../../avr-programs/upbracing-common"]
	end

	def cflags(source_dir, source_file, target_dir, configuration)
		dirs = additional_include_dirs(source_dir, source_file, target_dir, configuration)
		dir_flags = dirs.map { |dir|
			if dir.start_with? "#/"
				rel_path = dir[2..-1]
			elsif dir.start_with? "/"
				rel_path = dir
			else
				rel_path = File.join(source_dir, dir)
			end
			" '-I#{rel_path}'"
		}.join
		#puts dirs.inspect
		#puts dir_flags
		#puts CFLAGS[configuration]
		CFLAGS[configuration] + dir_flags
	end

	def do_compile(cflags, source, target)
		# only compile, put output in .o file
		sh "'#{CC}' #{cflags} -c -o '#{target}' '#{source}'"
	end

	def compile(source_dir, source_file, target_dir, configuration)
		target_file = source_file.sub(/(\.[^.]+)?$/, ".o").sub(/^([A-Za-z]:\\|#)?[.\/\\]/, "")

		target = File.join(target_dir, target_file)
		if source_file.start_with? "#/"
			source = source_file[2..-1]
		else
			source = File.join(source_dir, source_file)
		end

		# -MMD means only user header files
		# -MF is the output file
		# -MP create phony targets for the header files - we don't want that
		# -MT is the name of the target - we don't really care
		dependency_file = File.join(target_dir, target_file + ".d")
		make_dependencies_cflags = "-MMD -MF'#{dependency_file}' -MTtarget"

		cflags = cflags(source_dir, source_file, target_dir, configuration) + " " + make_dependencies_cflags

		# determine real target dir
		# This can be a subdirectory of target_dir because source_file
		# (and therefore target_file) can contain directory components.
		real_target_dir = File.dirname(target)
		directory real_target_dir

		t = file target => [source, file(real_target_dir)] do
			do_compile(cflags, source, target)
		end

		# if the dependency file exists, we read its contents
		if File.exists? dependency_file
			# read file contents
			x = File.read(dependency_file)
			# unwrap lines (backslash can escape a newline)
			x = x.gsub("\\\n", "")
			# get first line
			x = x.lines.first.strip
			# remove target name (before colon)
			x = x.sub(/^[^:]*:\s*/, "")
			# split on spaces
			x = x.split(/\s+/)
			# add dependencies to compile task
			#puts "dependencies for #{target}: #{x.inspect}"
			t.enhance x
		else
			# we don't know the dependencies -> always compile
			force = task unique_task_id("force") { }
			t.enhance [force]
		end

		return t
	end

	def link_elf(source_dir, target_dir, name, configuration, objs, libs)
		map_file = File.join(target_dir, "#{name}.map")
		target = File.join(target_dir, "#{name}.elf")
		objs_str = objs.map {|x| "'#{x}'"}.join(" ")
		file target => objs do
			libs = libs.call() if libs.is_a? Proc
			libs_str = libs.map {|x| "-l'#{x}'"}.join(" ")
			sh "'#{LD}' '-Wl,-Map,#{map_file}' -L'#{File.join(CARTOS_DIR, configuration)}' #{LDFLAGS[configuration]} -o '#{target}' #{objs_str} #{libs_str}"
		end
	end

	def name_from_source_dir(source_dir)
		#name = File.basename(source_dir) 	#TODO this won't work for nested folders
		name = source_dir
		name.sub(/^[0-9]+[-_ ]?/, "").gsub(/[\/\\][0-9]+[-_ ]?/, "/").gsub(/[\/\\]/, "-")
	end

	def get_target_dir(source_dir, configuration)
		File.join(source_dir, "bin", configuration)
	end

	def get_generator_config(source_dir, configuration)
		File.join(source_dir, "config.rb")
	end

	def get_features_header_file(source_dir, configuration)
		File.join(source_dir, "Os_cfg_features.h")
	end

	def get_generated_sources(source_dir, generator_config, gen_task)
		gen_task.dependent_files.select { |x| x =~ /\.c$/ }
	end

	def get_generated_features_header_file(source_dir, generator_config, gen_task, generated_sources)
		#TODO
		File.join(source_dir, "gen", "Os_cfg_features.h")
	end

	def get_libs(features_header_file, source_dir, name, configuration, sources)
		if features_header_file
			# The features header file might be regenerated, so we cannot know the MD5
			# right now. Instead, we supply a lambda that will be evaluated right before
			# the linker is called. We cache the result, so we won't have to calculate it
			# more than once.
			libs = nil
			return lambda do
				unless libs
					if features_header_file and File.exists? features_header_file
						features_md5 = md5sum(features_header_file)
						libs = ["caRtos-#{features_md5}"]
					else
						libs = []
					end
				end
				libs
			end
		else
			return []
		end
	end

	def create_lss_task(source_dir, target_dir, name, elf, configuration)
		# create extended listing
		# (not enforced by dependencies)
		lss_file = File.join(target_dir, "#{name}.lss")
		file lss_file => elf do
			sh "'#{OBJDUMP}' -h -S '#{elf.name}'  >'#{lss_file}'"
		end
	end

	def create_hex_task(source_dir, target_dir, name, elf, configuration)
		# create HEX task
		flash_hex_file = File.join(target_dir, "#{name}.hex")
		file flash_hex_file => elf do
			sh "'#{OBJCOPY}' -R .eeprom -O ihex '#{elf.name}' '#{flash_hex_file}'"
		end
	end

	def create_eeprom_task(source_dir, target_dir, name, elf, configuration)
		# create EEPROM HEX task
		# (not enforced by dependencies)
		eeprom_hex_file = File.join(target_dir, "#{name}.eep")
		file eeprom_hex_file => elf do
			flags = "-j .eeprom --no-change-warnings --change-section-lma .eeprom=0 -O ihex"
			sh "'#{OBJCOPY}' #{flags} '#{elf.name}' '#{eeprom_hex_file}'"
		end
	end

	def create_size_task(source_dir, target_dir, name, elf, configuration)
		# print size
		task "#{name}-size-#{configuration}" => elf do
			sh "'#{OBJSIZE}' --format=avr --mcu=at90can128 '#{elf.name}'"
		end
	end

	def additional_source_files(source_dir, name, configuration)
		[]
	end

	def build(source_dir, configuration)
		# output name is the name of the directory
		name = name_from_source_dir(source_dir)

		# determine target directory
		target_dir = get_target_dir(source_dir, configuration)

		# create generator task, if we have a config.rb file
		generator_config = get_generator_config(source_dir, configuration)
		features_header_file = nil
		generated_sources = []
		if generator_config and File.exists? generator_config
			# create generator task
			#TODO put generated files in bin folder?
			gen_task = generator_task(generator_config)

			# remember generated source files because we have to compile them
			generated_sources = get_generated_sources(source_dir, generator_config, gen_task)

			# create caRTOS library builder task
			# (uses generated features header)
			features_header_file = get_generated_features_header_file(source_dir, generator_config, gen_task, generated_sources)
		end

		# If we don't generate any files, we might still have a features header file.
		if !features_header_file
			maybe_features_header_file = get_features_header_file(source_dir, configuration)
			features_header_file = maybe_features_header_file if maybe_features_header_file and File.exists? maybe_features_header_file
		end

		# find all source files (*.c)
		sources = find_sources(source_dir)
		sources += generated_sources
		sources += additional_source_files(source_dir, name, configuration)
		# strip prefix from sources
		sources = sources.map { |source| relative_path source, source_dir }
		# remove duplicates (generated sources will be found, if they already exist)
		sources.uniq!

		# create compile tasks
		objs = sources.map { |source|  compile(source_dir, source, target_dir, configuration) }

		# make sure that we generate before we compile
		if gen_task
			objs.each do |obj|
				obj.enhance [gen_task]
			end
		end

		return nil unless objs and not objs.empty?

		# get libraries (probably a future value (Proc))
		libs = get_libs(features_header_file, source_dir, name, configuration, sources)

		# create linker task
		elf = link_elf(source_dir, target_dir, name, configuration, objs, libs)

		# make sure we build the caRTOS library before linking the application
		# (only if we have a features header file)
		if features_header_file
			cartos_lib_task = build_caRTOS(features_header_file, configuration)

			# add dependency to linker task
			elf.enhance [cartos_lib_task] if cartos_lib_task
		end

		create_lss_task(source_dir, target_dir, name, elf, configuration)

		flash_hex_file = create_hex_task(source_dir, target_dir, name, elf, configuration)
		
		create_eeprom_task(source_dir, target_dir, name, elf, configuration)

		create_size_task(source_dir, target_dir, name, elf, configuration)

		build_task = task("build-#{name}-#{configuration}" => flash_hex_file) {}

		# make sure that the hex file is generated, if someone calls build-all
		task :build_all => build_task

		# clean task
		clean = task "clean-#{name}-#{configuration}" do
			rm_rf target_dir
		end
		task "clean-#{name}" => clean

		# return hex file task
		flash_hex_file
	end
end

# Provide information about JRuby's notion of the current
# directory to RichToolkit. We have to do that because
# JRuby keeps its own copy of the current directory
# because in Java it cannot be changed.
# makeAbsolute methods has to be created in test script context to
# capture the right copy of the current directory (even in JRuby
# we have more than one *g*). Therefore, we save it as a string
# and execute it later.
RubyPWdProviderCode = <<EOF
class RubyPWdProvider
	include Java::de::upbracing::code_generation::tests::RichToolkit::PwdProvider

	def makeAbsolute(path)
		#puts "makeAbsolute(\#{path.inspect}) -> \#{File.expand_path(path || ".").inspect}"
		File.expand_path(path || ".")
	end
end
$toolkit.pwd_provider = RubyPWdProvider.new
EOF

PIOType = Java::de::upbracing::code_generation::tests::context::ProgramIO::Type
StringBuffer = Java::java::lang::StringBuffer
Messages = Java::de::upbracing::code_generation::Messages
Severity = Messages::Severity

begin
	OutputFormatter = Java::de::upbracing::code_generation::tests::simple::SimpleToolkit::OutputFormatter
rescue NameError
	# simple UI not available
	OutputFormatter = nil
end
if OutputFormatter
	class PaintOutputFormatter
		include OutputFormatter

		def alter_lines(text)
			text.lines.map { |line| yield line }.join
		end

		def alter_lines2(text)
			alter_lines(text) do |line|
				if line.end_with? "\n"
					line = line.sub(/\n$/, "")
					(yield line, true) + "\n"
				else
					yield line, false
				end
			end
		end

		def left_bar(bar, text)
			alter_lines(text) { |line| bar + line }
		end

		def printPrompt(prompt)
			if prompt and not prompt.empty?
				prompt = left_bar(Paint[" ", nil, :blue] + " ", prompt)
				print prompt
			end
		end

		def printInstructions(instructions)
			instructions = instructions.sub(/\n*$/, '')
			puts left_bar(Paint["I", :black, :white] + " ", instructions)
		end

		def printProgramIO(data, type)
			foreground = case type
			when PIOType::IN
				[:green]
			when PIOType::OUT
				[:white, :bright]
			when PIOType::ERROR
				[:red, :bright, :bold]
			else
				raise "unknown type of program IO: #{type}"
			end

			#data = data.gsub(/[^ -z]/) { |x| sprintf("\\x%02x", x.ord) }

			print alter_lines2(data) { |line| Paint[line, *foreground, [50,50,50]] }
		end

		def reportProgramResult(program, result)
			name = program.name
			#name = Paint[program.name, nil, [50,50,50]]

			if result.isSuccessful
				puts "#{name} finished successfully"
			else
				puts name + ": " + Paint[result.message, :red]
			end
		end

		def showMessage(msg)
			sb = StringBuffer.new
			msg.format(sb, "  ")
			color = case msg.severity
			when Severity::FATAL, Severity::ERROR
				[:red, :bright, :bold]
			when Severity::WARNING
				Paint.mode == 256 and ["#ff4a12", :bold] or [:yellow, :bold]
			else
				[:bold]	#nil
			end
			if color and Paint.mode > 0
				print sb.toString.sub(/^(.*):/, Paint["\\1", *color] + ":")
			else
				print sb.toString
			end
		end
	end
end

class TestHelper
	attr_accessor :toolkit
	attr_accessor :avrdude, :serialport
	attr_accessor :name, :build_dir, :source_dir, :configuration

	# set up environment for tests; called automatically
	def start
		$toolkit = @toolkit
		@toolkit.inner.output_formatter = PaintOutputFormatter.new if OutputFormatter
	end

	# delegate method calls to RichToolkit ($toolkit) or
	# the real Toolkit ($toolkit.inner), if this object
	# cannot handle them
	def method_missing(m, *args, &block)
		if toolkit.respond_to? m
			toolkit.send(m, *args, &block)
		elsif toolkit.inner.respond_to? m
			toolkit.inner.send(m, *args, &block)
		else
			# error
			super(m, *args, &block)
		end
	end

	def erase_processor
		system "#{@avrdude} -e"
	end

	def flash_processor_action(parts = [:flash])
		parts = [parts] if parts.is_a? String or parts.is_a? Symbol
		return { :dependencies => [], :action => lambda {}, :cmdline => "" } if parts.empty?

		dependencies = []
		commands = ""
		parts.each do |part|
			part = part.intern if part.is_a? String
			type = part.to_s
			case part
			when :flash, :application
				ext = "hex"
			when :eeprom
				ext = "eep"
			when :efuse, :lfuse, :hfuse, /^fuse[0-9]+$/, :calibration
				ext = part.to_s
			else
				raise "Unsupported type of memory: #{part}"
			end

			file = File.join(@build_dir, "#{@name}.#{ext}")
			dependencies << file
			commands += " '-U#{type}:w:#{File.expand_path(file)}:a'"
		end

		cmdline = @avrdude + commands

		{ :dependencies => dependencies, :cmdline => cmdline }
	end

	def flash_processor(parts = [:flash])
		system flash_processor_action(parts)[:cmdline]
	end
end

class Project

	## build Java helpers that are specific to this project

	ToolProvider = Java::javax::tools::ToolProvider

	def get_java_sources(java_source_dir)
		FileList[File.join(java_source_dir, "**", "*.java")]
	end

	def compiler_classpath(java_source_dir)
		Java::java::lang::System.getProperty("java.class.path")
	end

	def run_compiler(java_source_dir, java_output_dir)
		classpath = compiler_classpath(java_source_dir)
		args = ["-cp", classpath, "-sourcepath", java_source_dir, "-d", java_output_dir] \
			+ get_java_sources(java_source_dir)
		ToolProvider::getSystemJavaCompiler.run(nil, nil, nil, *args)
	end

	def get_java_source_dir(project_dir)
		File.join(project_dir, "java")
	end

	def get_java_output_dir(project_dir)
		File.join(project_dir, "bin", "java")
	end

	def create_java_task(project_dir)
		java_source_dir = get_java_source_dir(project_dir)
		if File.exists? java_source_dir
			java_output_dir = get_java_output_dir(project_dir)

			create_java_task2(project_dir, java_source_dir, java_output_dir)
		else
			nil
		end
	end

	def create_java_task2(project_dir, java_source_dir, java_output_dir)
		directory java_output_dir

		java_sources = get_java_sources(java_source_dir)
		class_files = java_sources.map { |x| x.sub(java_source_dir, java_output_dir).sub(/\.[^.]+$/, ".class") }

		compile_java_task = many_files "compile java files in #{java_source_dir}", class_files

		compile_java_task.enhance([file(java_output_dir)] + java_sources) do
			run_compiler(java_source_dir, java_output_dir)
		end

		compile_java_task
	end

	## run tests

	Ruby = Java::org::jruby::Ruby

	def run_jruby_script(script_filename, classpath = nil, global_variables = {})
		engine = Ruby.newInstance

		init_code = global_variables[:init]
		global_variables.delete :init

		global_variables.each do |key, value|
			#TODO support methods
			if key =~ /^[A-Z]/
				engine.defineGlobalConstant(key, value)
			elsif value.is_a? Method
				# we have to get the DynamicMethod object which
				# is stored in the private field method
				cls = Java::java::lang::Class.for_name("org.jruby.RubyMethod")
				field = cls.getDeclaredField("method")
				field.setAccessible true
				method = field.get(value)

				# We have to add it to some class or module. Here we are
				# using Kernel.
				#TODO I would like to add it to the main object, but I don't
				#     know how to get that object.
				target = engine.kernel

				# now we can set this on the Ruby instance
				# Unfortunately, we cannot access the addMethod method
				# directly, so we use reflection.
				mod_cls = Java::java::lang::Class.for_name("org.jruby.RubyModule")
				add_method = mod_cls.declared_methods.select {|x| x.name == "addMethod"}.first
				add_method.invoke(target, key.to_s, method)
			else
				engine.defineReadonlyVariable(key, value)
			end
		end

		# add some entries to the classpath
		if classpath
			engine.defineReadonlyVariable("$additional_classpath", classpath)
			engine.executeScript("$additional_classpath.each { |x| $CLASSPATH << x }", "extend classpath")
		end

		# load some helpers
		engine.executeScript(File.read("test-helpers.rb"), "test-helpers.rb")

		# change to directory of the script file
		engine.current_directory = File.expand_path(File.dirname(script_filename))

		# run init code
		engine.executeScript(init_code, "init code") if init_code

		# execute test script
		engine.executeScript(File.read(script_filename), script_filename)
	end

	def get_test_script(dir, configuration)
		File.join(dir, "run-test.rb")
	end

	def get_test_dependencies(project_dir, test_helper)
		test_helper.flash_processor_action()[:dependencies].map { |x| File.join(project_dir, x) }
	end

	def create_test_helper(name, build_dir)
		TestHelper.new
	end

	def test_classpath(project_dir, test_helper)
		java_source_dir = get_java_source_dir(project_dir)
		if File.exists? java_source_dir
			[get_java_output_dir(project_dir)]
		else
			[]
		end
	end

	def get_toolkit
		unless $toolkit
			$toolkit = Java::de::upbracing::code_generation::tests::TestUILoader.createToolkit(UI)
		end
		return $toolkit
	end

	def add_to_test_all(dir, configuration, test)
		#TODO How can we enforce the order? Does rake honour the order that
		#     we use for adding the dependencies?
		task :test_all => test
	end

	def run_test(dir, configuration)
		source_dir = dir
		name = name_from_source_dir source_dir

		build_dir = get_target_dir(dir, configuration)

		test_helper = create_test_helper(name, build_dir)
		test_helper.name          = name
		test_helper.build_dir     = relative_path build_dir,  dir
		test_helper.source_dir    = relative_path source_dir, dir
		test_helper.avrdude       = AVRDUDE
		test_helper.serialport    = SERIALPORT
		test_helper.configuration = configuration

		toolkit = get_toolkit
		test_helper.toolkit = toolkit

		test_script = get_test_script(dir, configuration)

		test = task "test-#{name}-#{configuration}" => get_test_dependencies(dir, test_helper) do
			puts "Running test '#{dir}' (#{configuration})..."

			raise "Test script not found at '#{test_script}'" unless File.exists? test_script

			classpath = test_classpath(dir, test_helper)

			begin
				run_jruby_script test_script, classpath,				\
					:AVRDUDE => AVRDUDE, :SERIALPORT => SERIALPORT, 	\
					"$helper" => test_helper,							\
					:init => "$helper.start" + "\n" + RubyPWdProviderCode
			rescue Exception => ex
				puts "Exception in test script #{test_script}:"
				puts ex.class
				puts ex.message
				puts ex.backtrace.join("\n")
			end
		end

		# alias for this task because I always get it wrong ;-)
		task "run-#{name}-#{configuration}" => test

		task "test-#{name}" => test
		task "run-#{name}" => test

		add_to_test_all(dir, configuration, test)

		return test
	end


	# main method

	def create_tasks(dir, dependencies_for_run)
		compile_java_task = create_java_task(dir)

		configurations(:build).each do |configuration|
			# build hex file
			build_task = build dir, configuration

			build_task.enhance [compile_java_task] if compile_java_task
		end

		# clean task
		name = name_from_source_dir dir
		clean = task "clean-#{name}" do
			target_dir = get_target_dir(dir, "")
			rmdir target_dir if Dir.exists?(target_dir) and Dir.empty?(target_dir)
		end
		task :clean => clean

		configurations(:test).each do |configuration|
			# run test
			run_task = run_test dir, configuration

			run_task.enhance dependencies_for_run
		end
	end

	def configurations(which)
		case which
		when :build
			BUILD_CONFIGURATIONS
		when :test
			TEST_CONFIGURATIONS
		else
			CONFIGURATIONS
		end
	end
end

class ProjectWithCommon < Project
	@@common_libraries = {
		"rs232" => { :sources => ["rs232.c", "rs232-helpers.c"] }
	}

	def initialize
		@used_common_source_files = []
	end

	def additional_include_dirs(source_dir, source_file, target_dir, configuration)
		["#/common"] + super
	end

	def additional_source_files(source_dir, name, configuration)
		@used_common_source_files + super
	end

	def add_common(*args)
		args.each do |arg|
			arg = arg.to_s
			lib = @@common_libraries[arg]
			if lib
				sources = lib[:sources].map { |file| "#/common/#{file}" }
				@used_common_source_files.push(*sources)
			elsif File.exists? "common/#{arg}.c"
				@used_common_source_files << "common/#{arg}.c"
			elsif File.exists? "common/#{arg}"
				@used_common_source_files << "common/#{arg}"
			else
				raise "not found: common file or library '#{arg}'"
			end
		end
	end
end

# We use ScriptEngine here. It should create a new instance of JRuby (and in some way
# it does), but it shares global variables and a few other things. This is quite convenient
# for loading the project config because it will need some rake stuff.
ScriptEngineManager = Java::javax::script::ScriptEngineManager
ScriptEngine = Java::javax::script::ScriptEngine
InputStreamReader = Java::java::io::InputStreamReader
Charset = Java::java::nio::charset::Charset
FileInputStream = Java::java::io::FileInputStream
def load_project_config(dir)
	project_config = File.join(dir, "project.rb")
	if File.exists? project_config
		jruby = ScriptEngineManager.new.getEngineByName("jruby")
		raise "Couldn't find the JRuby engine!" unless jruby

		#TODO give it a chance to alter the test object, as well
		jruby.put "Project", Project

		old_pwd = Dir.pwd
		jruby.put("directory", dir);
		jruby.eval("Dir.chdir($directory)");

		jruby.put(ScriptEngine.FILENAME, project_config)

		# save list of constants
		all_consts = Object.constants.clone

		script_reader = InputStreamReader.new(FileInputStream.new(project_config), Charset.forName("utf-8"));
		jruby.eval script_reader
		script_reader.close()

		# restore working directory
		Dir.chdir old_pwd

		project = jruby.get("project")

		# remove constants that have been created by the script
		#puts "new constants after loading #{project_config}: " + (Object.constants - all_consts).inspect
		keep_constants = jruby.get("keep_constants") || []
		(Object.constants - all_consts - keep_constants).each do |const_name|
			Object.send(:remove_const, const_name)
		end
	else
		project = Project.new
	end

	return project
end

# compile task for helpers project
#TODO This causes a NoSuchMethodError, if one of the changed
#     classes has a non-static inner class which accesses
#     some private or protected information in the parent
#     class. The compiler creates accessor methods and those
#     seem to be missing or inconsistent (like access$000).
# =>  Eclipse should do the build for us, so we should make
#     extra sure that we don't repeat it, unless we really
#     have to. At the moment, we rebuild if any source is
#     newer than any target. Instead we should match source
#     and target and compare only them. One target per source
#     is enough, so we don't have to worry about inner classes.
JAVA_HELPERS=File.join("..", "tests-java-helpers")
compile_helpers = Project.new.create_java_task2(JAVA_HELPERS,
	File.join(JAVA_HELPERS, "src"),
	File.join(JAVA_HELPERS, "bin"))
task :build_all => compile_helpers

# add tasks for all directories which have certain files
magic_files = FileList["**/run-test.rb", "**/config.rb", "**/project.rb", "**/main.c", "**/main-*.c"]
project_dirs = magic_files.map { |file| File.dirname(file) }
project_dirs.uniq!
project_dirs.sort!
project_dirs.each do |dir|
	puts "project: #{dir}"
	# special case: 'common' directory is not a test
	if dir != "common/"
		project = load_project_config(dir)

		project.create_tasks(dir, [compile_helpers]) if project

		#puts "-I: #{project.additional_include_dirs(nil,nil,nil,nil).inspect}"
	end
end

CODE_GENERATOR_DIR = ENV["CODE_GENERATOR_DIR"] || "../upbracing-AVR-CodeGenerator"
CARTOS_DIR = ENV["CARTOS_DIR"] || "../../caRTOS/XMEGAOs/os"

CC = "avr-gcc"
LD = CC
OBJCOPY = "avr-objcopy"
OBJDUMP = "avr-objdump"
OBJSIZE = "avr-size"

CONFIGURATIONS = ["Debug", "Release"]
BUILD_CONFIGURATIONS = CONFIGURATIONS
TEST_CONFIGURATIONS  = CONFIGURATIONS

F_CPU = 8000000
CFLAGS_COMMON = "-I'#{File.expand_path CARTOS_DIR}' -Wall -fpack-struct -fshort-enums -std=gnu99 -funsigned-char -funsigned-bitfields -mmcu=at90can128 -DF_CPU=#{F_CPU}UL"
CFLAGS = {
	"Debug" => CFLAGS_COMMON + " -g2 -gstabs -O0",
	"Release" => CFLAGS_COMMON + " -Os"
}

LDFLAGS_COMMON = "-mmcu=at90can128"
LDFLAGS = {
	"Debug" => LDFLAGS_COMMON,
	"Release" => LDFLAGS_COMMON
}


CODE_GENERATOR_BIN="#{CODE_GENERATOR_DIR}/run"
TARGET_DIR="gen"

# let the user change a few things, e.g. the programmer
# This file must set these constants:
# AVRDUDE = "avrdude -cjtag2 -pc128 -Pusb"
# SERIALPORT = "/dev/ttyUSB0"	# can be a Proc object
require 'userconfig.rb'

# make sure that we have all the constants we expect
user_config_error = false
[:AVRDUDE, :SERIALPORT].each do |name|
	unless Module.constants.include? name or Module.constants.include? name.to_s
		puts "Please set #{name} in userconfig.rb !"
		user_config_error = true
	else
		value = Module.const_get name
		unless value.is_a? String and !value.empty? or value.is_a? Proc
			puts "Invalid value for constant #{name}. Expecting a String or a Proc."
			user_config_error = true
		end
	end
end
exit 1 if user_config_error


require 'tempfile'
require 'digest/md5'
require 'java'


def md5sum(file)
	Digest::MD5.hexdigest(File.read(file))
end


class ManyFilesTask < Rake::Task
	attr_accessor :dependent_files

	def needed?
		@dependent_files.each do |file|
			file = file.name.to_s if file.is_a? Rake::FileTask
			if !File.exists?(file) or out_of_date?(File.mtime(file))
				puts "#{self} is outdated because of #{file} (exists: #{File.exists? file})"
				return true
			end
		end

		return false
	end

	# Are there any prerequisites with a later time than the given time stamp?
	def out_of_date?(stamp)
		#@prerequisites.any? { |n| application[n].timestamp > stamp}
		@prerequisites.each { |n|
			if application[n].timestamp > stamp
				puts "#{n} is newer (#{application[n].timestamp} > #{stamp})"
				return true
			end
		}
		return false
	end
end

def many_files(name, dependent_files, *args, &block)
	task = ManyFilesTask.define_task(name, *args, &block)
	task.dependent_files = dependent_files
	task
end


$unique_task_id_counter = 0
def unique_task_id(prefix)
	$unique_task_id_counter += 1
	"#{prefix}_#{$unique_task_id_counter}".intern
end


$caRTOS_builders = {}
def build_caRTOS(features_header_file, configuration = "Debug")
	#TODO make this a special kind of task and implement needed?
	task unique_task_id("caRTOS-lib") => features_header_file do |t|
		md5 = md5sum(features_header_file)
		target = File.join(CARTOS_DIR, configuration, "libcaRtos-#{md5}.a")
		cartos_build_dir = File.join(CARTOS_DIR, configuration)
		# rebuilt, if  library doesn't exist or any input file is newer
		# NOTE We cannot let 'make' decide because 'make' wouldn't rebuilt
		#      any file that has been compiled for a newer, totally different features
		#      file, if we keep the mtime of the features header.
		#      Therefore, we have to force a rebuild by touching the features header.
		os_deps = FileList[ ["*.c", "*.h", "*.inc"].map { |ext| File.join(CARTOS_DIR, "**", ext) } ]
		unless File.exists?(target) and File.mtime(target) >= File.mtime(features_header_file) \
				and os_deps.all? { |dep| File.mtime(target) >= File.mtime(dep) }
			# rebuild

			# we cannot generate the Makefile - Eclipse has to do that for us
			unless File.exists? File.join(cartos_build_dir, "makefile")
				raise "No Makefile found. Please use Eclipse to build caRTOS with configuration #{configuration} and try again."
			end

			# copy features header to OS
			features_header_for_build = File.join(CARTOS_DIR, "config", "Os_cfg_features.h")
			cp features_header_file, features_header_for_build

			# touch features header to force rebuild
			touch features_header_for_build

			# build
			sh "cd '#{cartos_build_dir}' ; make 'libcaRtos-#{md5}.a'"
		end
	end
end


def any_is_newer(old_files, new_files)
	new_files.each do |new_file|
		return true unless File.exists?(new_file)
		old_files.each do |old_file|
			if File.mtime(old_file) > File.mtime(new_file)
				return true
			end
		end
	end

	return false
end

$generator_tasks = {}
def generator_task(config_file)
	# use cached value, if it exists
	return $generator_tasks[config_file] if $generator_tasks[config_file]

	dir = File.dirname(config_file)

	target_dir = File.join(dir, TARGET_DIR)

	code_generator = "'#{CODE_GENERATOR_BIN}' -C '#{target_dir}' '#{config_file}'"

	# dependencies
	dependencies = `#{code_generator} -D`.lines.map {|x| x.strip}.to_a
	dependent_tasks = dependencies.map { |dep| file dep }

	# generated files
	generated_files = `#{code_generator} -w`.lines.map {|x| x.strip}.to_a

	gen_task = many_files "generate for #{config_file}", generated_files

	generated_files.each do |gen|
		file gen => gen_task
	end

	# generation task
	gen_task.enhance dependent_tasks do
		#if any_is_newer(dependencies, generated_files)
			sh "cd '#{dir}' ; '#{File.expand_path CODE_GENERATOR_BIN}' -C '#{TARGET_DIR}' '#{File.basename config_file}'"
		#end
	end

	task :generate_all => gen_task

	$generator_tasks[config_file] = gen_task

	return gen_task
end

# task generate_all tests all of them
task :generate_all do end

# make generate-all an alias for generate_all (only on the command line!)
task "generate-all" => :generate_all do end


def find_sources(dir)
	FileList.new(File.join(dir, "**", "*.c"))
end

def compile(source_dir, source_file, target_dir, configuration)
	target_file = source_file.sub(/(\.[^.]+)?$/, ".o")

	target = File.join(target_dir, target_file)
	source = File.join(source_dir, source_file)

	# -MMD means only user header files
	# -MF is the output file
	# -MP create phony targets for the header files - we don't want that
	# -MT is the name of the target - we don't really care
	dependency_file = File.join(target_dir, target_file + ".d")
	make_dependencies_cflags = "-MMD -MF'#{dependency_file}' -MTtarget"

	cflags = CFLAGS[configuration] + " " + make_dependencies_cflags

	# determine real target dir
	# This can be a subdirectory of target_dir because source_file
	# (and therefore target_file) can contain directory components.
	real_target_dir = File.dirname(target)
	directory real_target_dir

	t = file target => [source, file(real_target_dir)] do
		# only compile, put output in .o file
		sh "'#{CC}' #{cflags} -c -o '#{target}' '#{source}'"
	end

	# if the dependency file exists, we read its contents
	if File.exists? dependency_file
		# read file contents
		x = File.read(dependency_file)
		# unwrap lines (backslash can escape a newline)
		x = x.gsub("\\\n", "")
		# get first line
		x = x.lines.first.strip
		# remove target name (before colon)
		x = x.sub(/^[^:]*:\s*/, "")
		# split on spaces
		x = x.split(/\s+/)
		# add dependencies to compile task
		#puts "dependencies for #{target}: #{x.inspect}"
		t.enhance x
	else
		# we don't know the dependencies -> always compile
		force = task unique_task_id("force") { }
		t.enhance [force]
	end

	return t
end

def link_elf(source_dir, target_dir, name, configuration, objs, libs)
	map_file = File.join(target_dir, "#{name}.map")
	target = File.join(target_dir, "#{name}.elf")
	objs_str = objs.map {|x| "'#{x}'"}.join(" ")
	file target => objs do
		libs = libs.call() if libs.is_a? Proc
		libs_str = libs.map {|x| "-l'#{x}'"}.join(" ")
		sh "'#{LD}' '-Wl,-Map,#{map_file}' -L'#{File.join(CARTOS_DIR, configuration)}' #{LDFLAGS[configuration]} -o '#{target}' #{objs_str} #{libs_str}"
	end
end

def test_name_from_source_dir(source_dir)
	name = File.basename(source_dir)
	name.sub(/^[0-9]+[-_ ]?/, "")
end

def build(source_dir, configuration)
	#TODO read config file, if present

	# output name is the name of the directory
	name = test_name_from_source_dir(source_dir)

	# determine target directory
	target_dir = File.join(source_dir, "bin", configuration)

	# create generator task, if we have a config.rb file
	generator_config = File.join(source_dir, "config.rb")
	features_header_file = nil
	generated_sources = []
	if File.exists? generator_config
		# create generator task
		#TODO put generated files in bin folder?
		gen_task = generator_task(generator_config)

		# remember generated source files because we have to compile them
		generated_sources = gen_task.dependent_files.select { |x| x =~ /\.c$/ }

		# create caRTOS library builder task
		# (uses generated features header)
		features_header_file = File.join(source_dir, "gen", "Os_cfg_features.h")
	end

	# If we don't generate any files, we might still have a features header file.
	if !features_header_file
		maybe_features_header_file = File.join(source_dir, "Os_cfg_features.h")
		features_header_file = maybe_features_header_file if File.exists? maybe_features_header_file
	end

	# find all source files (*.c)
	sources = find_sources(source_dir) + generated_sources
	# remove duplicates (generated sources will be found, if they already exist)
	sources.uniq!
	# strip prefix from sources
	sources = sources.map do |source|
		if source.start_with? source_dir
			source = source[source_dir.length..-1]
			source = source[1..-1] if source.start_with? "/"
		end
		source
	end

	# create compile tasks
	objs = sources.map { |source|  compile(source_dir, source, target_dir, configuration) }

	# The features header file might be regenerated, so we cannot know the MD5
	# right now. Instead, we supply a lambda that will be evaluated right before
	# the linker is called. We cache the result, so we won't have to calculate it
	# more than once.
	libs = nil
	libs_future = lambda do
		unless libs
			if features_header_file
				features_md5 = md5sum(features_header_file)
				libs = ["caRtos-#{features_md5}"]
			else
				libs = []
			end
		end
		libs
	end

	# create linker task
	elf = link_elf(source_dir, target_dir, name, configuration, objs, libs_future)

	# make sure we build the caRTOS library before linking the application
	# (only if we have a features header file)
	if features_header_file
		cartos_lib_task = build_caRTOS(features_header_file, configuration)

		# add dependency to linker task
		elf.enhance [cartos_lib_task]
	end

	# create extended listing
	# (not enforced by dependencies)
	lss_file = File.join(target_dir, "#{name}.lss")
	file lss_file => elf do
		sh "'#{OBJDUMP}' -h -S '#{elf.name}'  >'#{lss_file}'"
	end

	# create HEX task
	flash_hex_file = File.join(target_dir, "#{name}.hex")
	file flash_hex_file => elf do
		sh "'#{OBJCOPY}' -R .eeprom -O ihex '#{elf.name}' '#{flash_hex_file}'"
	end

	# create EEPROM HEX task
	# (not enforced by dependencies)
	eeprom_hex_file = File.join(target_dir, "#{name}.eep")
	file eeprom_hex_file => elf do
		flags = "-j .eeprom --no-change-warnings --change-section-lma .eeprom=0 -O ihex"
		sh "'#{OBJCOPY}' #{flags} '#{elf.name}' '#{eeprom_hex_file}'"
	end

	# print size
	task "#{name}-size" => elf do
		sh "'#{OBJSIZE}' --format=avr --mcu=at90can128 '#{elf.name}'"
	end

	build_task = task("build-#{name}-#{configuration}" => flash_hex_file) {}

	# make sure that the hex file is generated, if someone calls build-all
	task :build_all => build_task

	# return hex file task
	flash_hex_file
end

# task build_all builds all hex files (through dependencies)
task :build_all do end

# make build-all an alias for build_all (only on the command line!)
task "build-all" => :build_all do end


def erase_processor
	sh "#{AVRDUDE} -e"
end

def flash_processor_action(build_dir, name, parts = [:flash])
	parts = [parts] if parts.is_a? String or parts.is_a? Symbol
	return { :dependencies => [], :action => lambda {}, :cmdline => "" } if parts.empty?

	dependencies = []
	commands = ""
	parts.each do |part|
		part = part.intern if part.is_a? String
		type = part.to_s
		case part
		when :flash, :application
			ext = "hex"
		when :eeprom
			ext = "eep"
		when :efuse, :lfuse, :hfuse, /^fuse[0-9]+$/, :calibration
			ext = part.to_s
		else
			raise "Unsupported type of memory: #{part}"
		end

		file = File.join(build_dir, "#{name}.#{ext}")
		dependencies << file
		commands += " '-U#{type}:w:#{File.expand_path(file)}:a'"
	end

	cmdline = AVRDUDE+commands

	{ :dependencies => dependencies, :action => lambda { sh cmdline }, :cmdline => cmdline }
end

Ruby = Java::org::jruby::Ruby

#NOTE The script should be executed in an isolated environment, but
#     unfortunately 
def run_jruby_script(script_filename, global_variables = {})
	engine = Ruby.newInstance

	global_variables.each do |key, value|
		#TODO support methods
		if key =~ /^[A-Z]/
			engine.defineGlobalConstant(key, value)
		elsif value.is_a? Method
			# we have to get the DynamicMethod object which
			# is stored in the private field method
			cls = Java::java::lang::Class.for_name("org.jruby.RubyMethod")
			field = cls.getDeclaredField("method")
			field.setAccessible true
			method = field.get(value)

			# We have to add it to some class or module. Here we are
			# using Kernel.
			#TODO I would like to add it to the main object, but I don't
			#     know how to get that object.
			target = engine.kernel

			# now we can set this on the Ruby instance
			# Unfortunately, we cannot access the addMethod method
			# directly, so we use reflection.
			mod_cls = Java::java::lang::Class.for_name("org.jruby.RubyModule")
			add_method = mod_cls.declared_methods.select {|x| x.name == "addMethod"}.first
			add_method.invoke(target, key.to_s, method)
		else
			engine.defineReadonlyVariable(key, value)
		end
	end

	# load some helpers
	engine.executeScript(File.read("test-helpers.rb"), "test-helpers.rb")

	# change to directory of the script file
	engine.current_directory = File.expand_path(File.dirname(script_filename))

	# execute test script
	engine.executeScript(File.read(script_filename), script_filename)
end

def run_test(dir, configuration)
	name = test_name_from_source_dir dir

	build_dir = File.join(dir, "bin", configuration)

	# get dependencies and commandline for flashing program to processor
	flash_info = flash_processor_action(build_dir, name)
	flash_cmdline = flash_info[:cmdline]

	# write flash command line to temporary file
	#flash_cmdline_file = Tempfile.new("flashcmd")
	#open(flash_cmdline_file, "w") do |f|
	#	f.write(flash_cmdline)
	#end

	test = task "test-#{name}-#{configuration}" => flash_info[:dependencies] do
		puts "Running test '#{dir}' (#{configuration})..."

		begin
			run_jruby_script File.join(dir, "run-test.rb"), \
				:AVRDUDE => AVRDUDE, :SERIALPORT => SERIALPORT, \
				"$flash_cmdline" => flash_cmdline
				#:erase_processor2 => method(:erase_processor), \
				#:sh => method(:sh)
		rescue Exception => ex
			puts "Exception in test script #{File.join(dir, "run-test.rb")}:"
			puts ex.message
			puts ex.backtrace.join("\n")
		end
	end

	#TODO How can we enforce the order? Does rake honour the order that
	#     we use for adding the dependencies?
	task :test_all => test

	#flash_cmdline_file.delete
end

# task test_all tests all of them
task :test_all do end

# make test-all an alias for test_all (only on the command line!)
task "test-all" => :test_all do end


# default action is building everything (for now - might change that to running the tests)
task :default => :build_all


# add tasks for all directories which have certain files
magic_files = FileList["**/run-test.rb", "**/config.rb", "**/main.c", "**/main-*.c"]
project_dirs = magic_files.map { |file| File.dirname(file) }
project_dirs.uniq!
project_dirs.sort
project_dirs.each do |dir|
	puts "project: #{dir}"
	# special case: 'common' directory is not a test
	if dir != "common/"
		BUILD_CONFIGURATIONS.each do |configuration|
			# build hex file
			build(dir, configuration)
		end

		TEST_CONFIGURATIONS.each do |configuration|
			# run test
			run_test dir, configuration
		end
	end
end


# some old debug tasks

#task :default => [build_caRTOS("features1.h"), build_caRTOS("features2.h"), build_caRTOS("features3.h", "Release")]
#task :default => generator_task("blub/config.rb")
#task :default => compile("blub", "main.c", "blub/bin/Debug", "Debug")

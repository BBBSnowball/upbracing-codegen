
#define ECU_NODE_ID 0x43

#ifndef NO_DBC_CAN_DEFS

#ifndef DEFS_MAIN_FILE


/////////////////////////
///  CAN definitions  ///
/////////////////////////

// CAN Message IDs:
typedef enum uint32_t {
	CAN_Bootloader_SelectNode        = 0x0,   	// receive                        
	CAN_Bootloader_1                 = 0x1,   	// receive                        
	CAN_RS232_FORWARD_DATA           = 0x1,   	// receive, alias for Bootloader_1
	CAN_ClutchGetPos                 = 0x5ff, 	// receive                        
	CAN_Kupplung_Soll                = 0x10,  	// receive                        
	CAN_Gear                         = 0x71,  	// receive                        
	CAN_Sensoren                     = 0x80,  	// receive                        
	CAN_Sensoren_2                   = 0x81,  	// receive                        
	CAN_OpenSquirt_Engine            = 0x88,  	// receive                        
	CAN_Kupplung_Calibration         = 0x101, 	// receive                        
	CAN_OpenSquirt_Sensoren1         = 0x108, 	// receive                        
	CAN_Geschwindigkeit              = 0x110, 	// receive                        
	CAN_Lenkrad_main2display         = 0x4201,	// receive                        
	CAN_Launch                       = 0x60,  	// send                           
	CAN_Radio                        = 0x90,  	// send                           
	CAN_Kupplung_Calibration_Control = 0x250, 	// send                           
	CAN_CockpitBrightness            = 0x4242,	// send                           
} CAN_msgID;

// do the messages use extended CAN ids or not (0 = standard, 1 = extended)
typedef enum {
	CAN_Bootloader_SelectNode_IsExtended        = 0,
	CAN_Bootloader_1_IsExtended                 = 0,
	CAN_RS232_FORWARD_DATA_IsExtended           = 0,
	CAN_ClutchGetPos_IsExtended                 = 0,
	CAN_Kupplung_Soll_IsExtended                = 1,
	CAN_Gear_IsExtended                         = 1,
	CAN_Sensoren_IsExtended                     = 1,
	CAN_Sensoren_2_IsExtended                   = 1,
	CAN_OpenSquirt_Engine_IsExtended            = 1,
	CAN_Kupplung_Calibration_IsExtended         = 1,
	CAN_OpenSquirt_Sensoren1_IsExtended         = 1,
	CAN_Geschwindigkeit_IsExtended              = 1,
	CAN_Lenkrad_main2display_IsExtended         = 1,
	CAN_Launch_IsExtended                       = 1,
	CAN_Radio_IsExtended                        = 1,
	CAN_Kupplung_Calibration_Control_IsExtended = 1,
	CAN_CockpitBrightness_IsExtended            = 1,
} CAN_isExtended;

/*
tx_msgs: Kupplung_Calibration_Control Launch Radio CockpitBrightness
rx_msgs: OpenSquirt_Sensoren1 OpenSquirt_Engine Gear Lenkrad_main2display ClutchGetPos Bootloader_SelectNode Kupplung_Calibration Sensoren_2 Geschwindigkeit Sensoren Kupplung_Soll Bootloader_1
rx_signals: Boardspannung Temp_Ansaug Temp_Wasser ThrottlePosition Lambda Druck_Ansaug Drehzahl Gang Lenkrad_main2display Clutch_IstPosition Bootloader_SelectNode Kupplung_RAW Druck_Kraftstoff Geschwindigkeit Druck_Oel Temp_Oel Kupplung_Soll
*/

#ifndef DONT_SET_VALUE_TABLES
#ifndef SKIP_VT_boolean
typedef bool boolean;
#endif	// not defined SKIP_VT_boolean
#ifndef SKIP_VT_main2display
typedef enum _main2display {
	BOOTLOADER_ACTIVE = 3,
	START_FLIPPER = 2,
	START_TETRIS = 1,
	MAIN_ACK = 0,
} main2display;
#endif	// not defined SKIP_VT_main2display
#ifndef SKIP_VT_BootloaderNode
typedef enum _BootloaderNode {
	LenkradCANtoRS232 = 68,
	LenkradDisplay = 67,
	LenkradMain = 66,
	Sensorboard = 71,
} BootloaderNode;
#endif	// not defined SKIP_VT_BootloaderNode
#endif	// not defined DONT_SET_VALUE_TABLES
#endif	// not defined DEFS_MAIN_FILE

#ifndef DEFS_MAIN_FILE

typedef enum {
	MOB_Bootloader_SelectNode = 1,  	// CAN ID: 0x0, receive                        
	MOB_Bootloader_1          = 2,  	// CAN ID: 0x1, receive                        
	MOB_RS232_FORWARD_DATA    = 2,  	// CAN ID: 0x1, receive, alias for Bootloader_1
	MOB_ClutchGetPos          = 3,  	// CAN ID: 0x5ff, receive                      
	MOB_Kupplung              = 4,  	// CAN ID: 0x10x, receive                      
	MOB_Gear                  = 5,  	// CAN ID: 0x71x, receive                      
	MOB_Sensoren              = 6,  	// CAN ID: 0x80x, receive                      
	MOB_Sensoren_2            = 7,  	// CAN ID: 0x81x, receive                      
	MOB_OpenSquirt_Engine     = 8,  	// CAN ID: 0x88x, receive                      
	MOB_OpenSquirt_Sensoren1  = 9,  	// CAN ID: 0x108x, receive                     
	MOB_Geschwindigkeit       = 10, 	// CAN ID: 0x110x, receive                     
	MOB_Lenkrad_main2display  = 11, 	// CAN ID: 0x4201x, receive                    
	MOB_Launch                = 12, 	// CAN ID: 0x60x, send                         
	MOB_Radio                 = 13, 	// CAN ID: 0x90x, send                         

	MOB_GENERAL_MESSAGE_TRANSMITTER = 14
} MessageObjectID;

#endif	// not defined DEFS_MAIN_FILE

#include "can_at90.h"

#ifndef DEFS_MAIN_FILE
// we use interrupts - polling isn't necessary
inline static void can_poll(void) { }
#endif

#ifdef DEFS_MAIN_FILE
// CAN receive interrupt
ISR(SIG_CAN_INTERRUPT1) {
	if (CANSIT1==0 && CANSIT2==0)
		//TODO we HAVE to reset the interrupt reason!
		return;

	uint8_t saved_canpage = CANPAGE;

	if (0) {	// dummy clause to make code generation easier
	} else if (can_caused_interrupt(MOB_Bootloader_SelectNode)) {		// CAN ID: 0x0 
		CANPAGE = (MOB_Bootloader_SelectNode<<4);
		handle_bootloader_selectnode();
		// only necessary, if we change CANPAGE in our message handler
		// But if we forget to do that, the interrupt handler will be called forever.
		CANPAGE = (MOB_Bootloader_SelectNode<<4);
	} else if (can_caused_interrupt(MOB_Bootloader_1)) {		// CAN ID: 0x1, alias: RS232_FORWARD_DATA 
		CANPAGE = (MOB_Bootloader_1<<4);
		handle_rs232_forward_data();
		// only necessary, if we change CANPAGE in our message handler
		// But if we forget to do that, the interrupt handler will be called forever.
		CANPAGE = (MOB_Bootloader_1<<4);
	} else if (can_caused_interrupt(MOB_ClutchGetPos)) {		// CAN ID: 0x5ff 
		CANPAGE = (MOB_ClutchGetPos<<4);
		handle_clutch_actuator();
		// only necessary, if we change CANPAGE in our message handler
		// But if we forget to do that, the interrupt handler will be called forever.
		CANPAGE = (MOB_ClutchGetPos<<4);
	} else if (can_caused_interrupt(MOB_Kupplung)) {		// shared mob 
		CANPAGE = (MOB_Kupplung<<4);
		if (0) {	// dummy clause to make code generation easier
		} else if (1 && CANIDT3 == 0 && CANIDT4 == 128) {		// Kupplung_Soll, CAN ID: 0x10x

			// reading signal Kupplung_Soll
			{
				uint8_t value = CANMSG;
				if (!demo_mode) {
					display_values[DI_Kupplung_Soll].value8 = value;
					display_values[DI_Kupplung_Soll].changed = 1;
				}
			}
			clutch_calibration_mode = false;
		} else if (1 && CANIDT3 == 8 && CANIDT4 == 8) {		// Kupplung_Calibration, CAN ID: 0x101x

			// reading signal Kupplung_RAW
			{
				union {
					uint16_t value;
					struct {
						uint8_t byte0;
						uint8_t byte1;
					} bytes;
				} x;
				x.bytes.byte1 = CANMSG;
				x.bytes.byte0 = CANMSG;
				uint16_t value = x.value;
				display_values[DI_Kupplung_Soll].value8 = value / 4;
				display_values[DI_Kupplung_Soll].changed = 1;
			}
			clutch_calibration_mode = true;
		}
		// only necessary, if we change CANPAGE in our message handler
		// But if we forget to do that, the interrupt handler will be called forever.
		CANPAGE = (MOB_Kupplung<<4);
	} else if (can_caused_interrupt(MOB_Gear)) {		// CAN ID: 0x71x 
		CANPAGE = (MOB_Gear<<4);

		// reading signal Gang
		{
			uint8_t value = CANMSG;
			display_values[DI_Geschwindigkeit].value8 = value;
			display_values[DI_Geschwindigkeit].changed = 1;
		}
		// only necessary, if we change CANPAGE in our message handler
		// But if we forget to do that, the interrupt handler will be called forever.
		CANPAGE = (MOB_Gear<<4);
	} else if (can_caused_interrupt(MOB_Sensoren)) {		// CAN ID: 0x80x 
		CANPAGE = (MOB_Sensoren<<4);

		// skipping 2 byte(s)
		CANMSG;
		CANMSG;

		// reading signal Temp_Oel
		{
			uint8_t value = CANMSG;
			if (!demo_mode) {
				display_values[DI_Temp_Oel].value8 = value;
				display_values[DI_Temp_Oel].changed = 1;
			}
			SET(LED_OELTEMP, (value > 115));
		}

		// skipping 1 byte(s)
		CANMSG;

		// reading signal Druck_Oel
		{
			union {
				uint16_t value;
				struct {
					uint8_t byte0;
					uint8_t byte1;
				} bytes;
			} x;
			x.bytes.byte0 = CANMSG;
			x.bytes.byte1 = CANMSG;
			uint16_t value = x.value;
			if (!demo_mode) {
				display_values[DI_Druck_Oel].value16 = value;
				display_values[DI_Druck_Oel].changed = 1;
			}
			SET(LED_OELDRUCK, (value < 250));
		}
		// only necessary, if we change CANPAGE in our message handler
		// But if we forget to do that, the interrupt handler will be called forever.
		CANPAGE = (MOB_Sensoren<<4);
	} else if (can_caused_interrupt(MOB_Sensoren_2)) {		// CAN ID: 0x81x 
		CANPAGE = (MOB_Sensoren_2<<4);

		// reading signal Druck_Kraftstoff
		{
			union {
				uint16_t value;
				struct {
					uint8_t byte0;
					uint8_t byte1;
				} bytes;
			} x;
			x.bytes.byte0 = CANMSG;
			x.bytes.byte1 = CANMSG;
			uint16_t value = x.value;
			if (!demo_mode) {
				display_values[DI_Druck_Kraftstoff].value16 = value;
				display_values[DI_Druck_Kraftstoff].changed = 1;
			}
		}
		// only necessary, if we change CANPAGE in our message handler
		// But if we forget to do that, the interrupt handler will be called forever.
		CANPAGE = (MOB_Sensoren_2<<4);
	} else if (can_caused_interrupt(MOB_OpenSquirt_Engine)) {		// CAN ID: 0x88x 
		CANPAGE = (MOB_OpenSquirt_Engine<<4);

		// reading signal Drehzahl
		{
			union {
				uint16_t value;
				struct {
					uint8_t byte0;
					uint8_t byte1;
				} bytes;
			} x;
			x.bytes.byte1 = CANMSG;
			x.bytes.byte0 = CANMSG;
			uint16_t value = x.value;
			static uint8_t rpm_update_counter = 254;
			if (rpm_update_counter >= 10) {
				rpm_update_counter = 0;
				sevenseg_set(value, 1);
			} else
				rpm_update_counter++;
		}

		// reading signal Druck_Ansaug
		{
			union {
				int16_t value;
				struct {
					uint8_t byte0;
					uint8_t byte1;
				} bytes;
			} x;
			x.bytes.byte1 = CANMSG;
			x.bytes.byte0 = CANMSG;

#warning This signal uses factor or offset, which is not supported yet.

			int16_t value = x.value;
			if (!demo_mode) {
				display_values[DI_Druck_Ansaug].value16 = value;
				display_values[DI_Druck_Ansaug].changed = 1;
			}
		}

		// reading signal Lambda
		{
			union {
				int16_t value;
				struct {
					uint8_t byte0;
					uint8_t byte1;
				} bytes;
			} x;
			x.bytes.byte1 = CANMSG;
			x.bytes.byte0 = CANMSG;

#warning This signal uses factor or offset, which is not supported yet.

			int16_t value = x.value;
			if (!demo_mode) {
				display_values[DI_Lambda].value16 = value * 100 / 147;
				display_values[DI_Lambda].changed = 1;
			}
		}

		// reading signal ThrottlePosition
		{
			union {
				int16_t value;
				struct {
					uint8_t byte0;
					uint8_t byte1;
				} bytes;
			} x;
			x.bytes.byte1 = CANMSG;
			x.bytes.byte0 = CANMSG;

#warning This signal uses factor or offset, which is not supported yet.

			int16_t value = x.value;
			ThrottlePosition = value;
		}
		// only necessary, if we change CANPAGE in our message handler
		// But if we forget to do that, the interrupt handler will be called forever.
		CANPAGE = (MOB_OpenSquirt_Engine<<4);
	} else if (can_caused_interrupt(MOB_OpenSquirt_Sensoren1)) {		// CAN ID: 0x108x 
		CANPAGE = (MOB_OpenSquirt_Sensoren1<<4);

		// reading signal Temp_Wasser
		{
			union {
				int16_t value;
				struct {
					uint8_t byte0;
					uint8_t byte1;
				} bytes;
			} x;
			x.bytes.byte1 = CANMSG;
			x.bytes.byte0 = CANMSG;

#warning This signal uses factor or offset, which is not supported yet.

			int16_t value = x.value;
			if (!demo_mode) {
				display_values[DI_Temp_Wasser].value16 = (value-320) * 5 / 9;
				display_values[DI_Temp_Wasser].changed = 1;
			}
			SET(LED_WASSERTEMP, (value > 105));
		}

		// reading signal Temp_Ansaug
		{
			union {
				int16_t value;
				struct {
					uint8_t byte0;
					uint8_t byte1;
				} bytes;
			} x;
			x.bytes.byte1 = CANMSG;
			x.bytes.byte0 = CANMSG;

#warning This signal uses factor or offset, which is not supported yet.

			int16_t value = x.value;
			if (!demo_mode) {
				display_values[DI_Temp_Ansaug].value16 = (value-320) * 5 / 9;
				display_values[DI_Temp_Ansaug].changed = 1;
			}
		}

		// reading signal Boardspannung
		{
			union {
				int16_t value;
				struct {
					uint8_t byte0;
					uint8_t byte1;
				} bytes;
			} x;
			x.bytes.byte1 = CANMSG;
			x.bytes.byte0 = CANMSG;

#warning This signal uses factor or offset, which is not supported yet.

			int16_t value = x.value;
			if (!demo_mode) {
				display_values[DI_Boardspannung].value16 = value;
				display_values[DI_Boardspannung].changed = 1;
			}
		}
		// only necessary, if we change CANPAGE in our message handler
		// But if we forget to do that, the interrupt handler will be called forever.
		CANPAGE = (MOB_OpenSquirt_Sensoren1<<4);
	} else if (can_caused_interrupt(MOB_Geschwindigkeit)) {		// CAN ID: 0x110x 
		CANPAGE = (MOB_Geschwindigkeit<<4);

		// reading signal Geschwindigkeit
		{
			uint8_t value = CANMSG;
			Geschwindigkeit = value;
		}
		// only necessary, if we change CANPAGE in our message handler
		// But if we forget to do that, the interrupt handler will be called forever.
		CANPAGE = (MOB_Geschwindigkeit<<4);
	} else if (can_caused_interrupt(MOB_Lenkrad_main2display)) {		// CAN ID: 0x4201x 
		CANPAGE = (MOB_Lenkrad_main2display<<4);
		handle_main2display();
		// only necessary, if we change CANPAGE in our message handler
		// But if we forget to do that, the interrupt handler will be called forever.
		CANPAGE = (MOB_Lenkrad_main2display<<4);
	} else {
		// well, this shouldn't happen
		// do nothing...
	}

    // reset INT reason
    CANSTMOB &= ~(1<<RXOK);
    // re-enable RX, reconfigure MOb IDE=1
    //CANCDMOB = (1<<CONMOB1) | (1<<IDE);
    CANCDMOB |= (1<<CONMOB1);

    // restore CANPAGE
    CANPAGE = saved_canpage;
}
#endif

#ifdef DEFS_MAIN_FILE
inline static void can_init_MOB_Bootloader_SelectNode(void) { can_mob_init_receive2(MOB_Bootloader_SelectNode, CAN_Bootloader_SelectNode, false); }
inline static void can_init_MOB_Bootloader_1(void) { can_mob_init_receive2(MOB_Bootloader_1, CAN_Bootloader_1, false); }
inline static void can_init_MOB_ClutchGetPos(void) { can_mob_init_receive2(MOB_ClutchGetPos, CAN_ClutchGetPos, false); }
inline static void can_init_MOB_Kupplung(void) {
	// select MOB
	CANPAGE = (MOB_Kupplung<<4);

	// set id and mask
	CANIDT1 = 0x00;
	CANIDT2 = 0x00;
	CANIDT3 = 0x08;
	CANIDT4 = 0x88;
	CANIDM1 = 0xff;
	CANIDM2 = 0xff;
	CANIDM3 = 0xf7;
	CANIDM4 = 0x75;

	//configure message as receive-msg (see CANCDMOB register, page257)
	CANCDMOB = (1<<CONMOB1) | (1<<IDE);

	// enable interrupts for this MOb
	can_mob_enable(MOB_Kupplung);
	can_mob_enable_interrupt(MOB_Kupplung);
}
inline static void can_init_MOB_Gear(void) { can_mob_init_receive2(MOB_Gear, CAN_Gear, true); }
inline static void can_init_MOB_Sensoren(void) { can_mob_init_receive2(MOB_Sensoren, CAN_Sensoren, true); }
inline static void can_init_MOB_Sensoren_2(void) { can_mob_init_receive2(MOB_Sensoren_2, CAN_Sensoren_2, true); }
inline static void can_init_MOB_OpenSquirt_Engine(void) { can_mob_init_receive2(MOB_OpenSquirt_Engine, CAN_OpenSquirt_Engine, true); }
inline static void can_init_MOB_OpenSquirt_Sensoren1(void) { can_mob_init_receive2(MOB_OpenSquirt_Sensoren1, CAN_OpenSquirt_Sensoren1, true); }
inline static void can_init_MOB_Geschwindigkeit(void) { can_mob_init_receive2(MOB_Geschwindigkeit, CAN_Geschwindigkeit, true); }
inline static void can_init_MOB_Lenkrad_main2display(void) { can_mob_init_receive2(MOB_Lenkrad_main2display, CAN_Lenkrad_main2display, true); }
inline static void can_init_MOB_Launch(void) { can_mob_init_transmit2(MOB_Launch, CAN_Launch, true); }
inline static void can_init_MOB_Radio(void) { can_mob_init_transmit2(MOB_Radio, CAN_Radio, true); }

inline static void can_init_mobs(void) {
	can_init_MOB_Bootloader_SelectNode();
	// not initialising disabled MOB MOB_Bootloader_1 for messages 
	can_init_MOB_ClutchGetPos();
	can_init_MOB_Kupplung();
	can_init_MOB_Gear();
	can_init_MOB_Sensoren();
	can_init_MOB_Sensoren_2();
	can_init_MOB_OpenSquirt_Engine();
	can_init_MOB_OpenSquirt_Sensoren1();
	can_init_MOB_Geschwindigkeit();
	can_init_MOB_Lenkrad_main2display();
	can_init_MOB_Launch();
	can_init_MOB_Radio();
}
#endif

#ifndef DEFS_MAIN_FILE
// 0x60x
inline static void send_Launch(bool wait, boolean Launch) {
	// select MOB
	CANPAGE = (MOB_Launch<<4);

	// wait for an ongoing transmission to finish
	can_mob_wait_for_transmission_of_current_mob();

	// reset transmission status
	CANSTMOB = 0;

	can_mob_init_transmit2(MOB_Launch, CAN_Launch, CAN_Launch_IsExtended);

	// disable mob, as it would be retransmitted otherwise
	CANCDMOB = (CANCDMOB&0x30) | ((1&0xf)<<DLC0);

		// writing signal Launch
		{
			boolean value;
			value = Launch;
			CANMSG = (uint8_t) value;
		}
	if (wait)
		can_mob_transmit_wait(MOB_Launch);
	else
		can_mob_transmit_nowait(MOB_Launch);
}
inline static void send_Launch_wait(boolean Launch) {
	send_Launch(true, Launch);
}
inline static void send_Launch_nowait(boolean Launch) {
	send_Launch(false, Launch);
}
// 0x90x
inline static void send_Radio(bool wait, boolean Radio) {
	// select MOB
	CANPAGE = (MOB_Radio<<4);

	// wait for an ongoing transmission to finish
	can_mob_wait_for_transmission_of_current_mob();

	// reset transmission status
	CANSTMOB = 0;

	can_mob_init_transmit2(MOB_Radio, CAN_Radio, CAN_Radio_IsExtended);

	// disable mob, as it would be retransmitted otherwise
	CANCDMOB = (CANCDMOB&0x30) | ((1&0xf)<<DLC0);

		// writing signal Radio
		{
			boolean value;
			value = Radio;
			CANMSG = (uint8_t) value;
		}
	if (wait)
		can_mob_transmit_wait(MOB_Radio);
	else
		can_mob_transmit_nowait(MOB_Radio);
}
inline static void send_Radio_wait(boolean Radio) {
	send_Radio(true, Radio);
}
inline static void send_Radio_nowait(boolean Radio) {
	send_Radio(false, Radio);
}
// 0x250x
inline static void send_Kupplung_Calibration_Control(bool wait, boolean KupplungKalibrationActive) {
	// select MOB
	CANPAGE = (MOB_GENERAL_MESSAGE_TRANSMITTER<<4);

	// wait for an ongoing transmission to finish
	can_mob_wait_for_transmission_of_current_mob();

	// reset transmission status
	CANSTMOB = 0;

	can_mob_init_transmit2(MOB_GENERAL_MESSAGE_TRANSMITTER, CAN_Kupplung_Calibration_Control, CAN_Kupplung_Calibration_Control_IsExtended);

	// disable mob, as it would be retransmitted otherwise
	CANCDMOB = (CANCDMOB&0x30) | ((1&0xf)<<DLC0);

		// writing signal KupplungKalibrationActive
		{
			boolean value;
			value = KupplungKalibrationActive;
			CANMSG = (uint8_t) value;
		}
	if (wait)
		can_mob_transmit_wait(MOB_GENERAL_MESSAGE_TRANSMITTER);
	else
		can_mob_transmit_nowait(MOB_GENERAL_MESSAGE_TRANSMITTER);
}
inline static void send_Kupplung_Calibration_Control_wait(boolean KupplungKalibrationActive) {
	send_Kupplung_Calibration_Control(true, KupplungKalibrationActive);
}
inline static void send_Kupplung_Calibration_Control_nowait(boolean KupplungKalibrationActive) {
	send_Kupplung_Calibration_Control(false, KupplungKalibrationActive);
}
// 0x4242x
inline static void send_CockpitBrightness(bool wait, uint8_t CockpitRPMBrightness, uint8_t CockpitGangBrightness) {
	// select MOB
	CANPAGE = (MOB_GENERAL_MESSAGE_TRANSMITTER<<4);

	// wait for an ongoing transmission to finish
	can_mob_wait_for_transmission_of_current_mob();

	// reset transmission status
	CANSTMOB = 0;

	can_mob_init_transmit2(MOB_GENERAL_MESSAGE_TRANSMITTER, CAN_CockpitBrightness, CAN_CockpitBrightness_IsExtended);

	// disable mob, as it would be retransmitted otherwise
	CANCDMOB = (CANCDMOB&0x30) | ((3&0xf)<<DLC0);

		// writing signal CockpitRPMBrightness
		{
			uint8_t value;
			value = CockpitRPMBrightness;
			CANMSG = value;
		}

		// writing signal CockpitGangBrightness
		{
			uint8_t value;
			value = CockpitGangBrightness;
			CANMSG = value;
		}
	if (wait)
		can_mob_transmit_wait(MOB_GENERAL_MESSAGE_TRANSMITTER);
	else
		can_mob_transmit_nowait(MOB_GENERAL_MESSAGE_TRANSMITTER);
}
inline static void send_CockpitBrightness_wait(uint8_t CockpitRPMBrightness, uint8_t CockpitGangBrightness) {
	send_CockpitBrightness(true, CockpitRPMBrightness, CockpitGangBrightness);
}
inline static void send_CockpitBrightness_nowait(uint8_t CockpitRPMBrightness, uint8_t CockpitGangBrightness) {
	send_CockpitBrightness(false, CockpitRPMBrightness, CockpitGangBrightness);
}
#endif

#endif	// NO_DBC_CAN_DEFS not defined

#warning There were some warnings
/*
  warning: This signal uses factor or offset, which is not supported yet.
  warning: This signal uses factor or offset, which is not supported yet.
  warning: This signal uses factor or offset, which is not supported yet.
  warning: This signal uses factor or offset, which is not supported yet.
  warning: This signal uses factor or offset, which is not supported yet.
  warning: This signal uses factor or offset, which is not supported yet.
*/
